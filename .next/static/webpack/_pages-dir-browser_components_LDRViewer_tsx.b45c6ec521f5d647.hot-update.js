"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_LDRViewer_tsx",{

/***/ "(pages-dir-browser)/./components/LDRViewer.tsx":
/*!**********************************!*\
  !*** ./components/LDRViewer.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(pages-dir-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls.js */ \"(pages-dir-browser)/./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n/* harmony import */ var three_examples_jsm_loaders_LDrawLoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/loaders/LDrawLoader.js */ \"(pages-dir-browser)/./node_modules/three/examples/jsm/loaders/LDrawLoader.js\");\n/* harmony import */ var three_examples_jsm_materials_LDrawConditionalLineMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/materials/LDrawConditionalLineMaterial.js */ \"(pages-dir-browser)/./node_modules/three/examples/jsm/materials/LDrawConditionalLineMaterial.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst LDRViewerComponent = (param)=>{\n    let { modelPath, ldrawContent, preserveCamera } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sceneRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const rendererRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const cameraRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const modelGroupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const loadingManagerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isLoadingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const currentModelPathRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)('');\n    const isInitializedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const errorCountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Error state for displaying messages\n    const [loadError, setLoadError] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(null);\n    // Camera state preservation\n    const savedCameraPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const savedCameraTarget = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Step control\n    const [currentStep, setCurrentStep] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(1);\n    const [totalSteps, setTotalSteps] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(1);\n    const stepsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const allPartsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Create loading manager only once\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            if (loadingManagerRef.current) return;\n            const manager = new three__WEBPACK_IMPORTED_MODULE_2__.LoadingManager();\n            // Implement path resolution strategy similar to Three.js packLDrawModel\n            manager.setURLModifier({\n                \"LDRViewerComponent.useEffect\": (url)=>{\n                    // console.log('Original URL:', url);\n                    // Normalize path separators\n                    let normalized = url.replace(/\\\\/g, '/');\n                    // Handle s\\ prefix for subparts (convert s\\file.dat to s/file.dat)\n                    if (normalized.includes('s/') || normalized.match(/s[\\\\\\/]/)) {\n                        const parts = normalized.split(/[\\\\\\/]/);\n                        const lastTwo = parts.slice(-2);\n                        if (lastTwo[0] === 's') {\n                            // This is a subpart reference\n                            normalized = \"/ldraw/parts/s/\".concat(lastTwo[1]);\n                            // console.log('Subpart detected, normalized to:', normalized);\n                            return normalized;\n                        }\n                    }\n                    // Extract the filename and check for subdirectory (like s/)\n                    const urlParts = normalized.split('/');\n                    const filename = urlParts[urlParts.length - 1].toLowerCase();\n                    const hasSubdir = urlParts.length >= 2 && urlParts[urlParts.length - 2] === 's';\n                    // Define possible path prefixes to try\n                    const pathPrefixes = [\n                        '/output/',\n                        '/ldraw/',\n                        '/ldraw/p/',\n                        '/ldraw/parts/'\n                    ];\n                    // If the URL already has a valid prefix, clean it up\n                    for (const prefix of pathPrefixes){\n                        if (normalized.includes(prefix)) {\n                            // Clean up any duplicate path segments\n                            normalized = normalized.replace(/\\/ldraw\\/parts\\/parts\\//g, '/ldraw/parts/');\n                            normalized = normalized.replace(/\\/ldraw\\/p\\/p\\//g, '/ldraw/p/');\n                            normalized = normalized.replace(/\\/output\\/output\\//g, '/output/');\n                            // Remove any redundant path combinations but preserve s/ subdirectory\n                            if (!normalized.includes('/s/')) {\n                                normalized = normalized.replace(/\\/ldraw\\/parts\\/p\\//g, '/ldraw/p/');\n                                normalized = normalized.replace(/\\/output\\/p\\//g, '/ldraw/p/');\n                                normalized = normalized.replace(/\\/ldraw\\/p\\/parts\\//g, '/ldraw/parts/');\n                                normalized = normalized.replace(/\\/output\\/parts\\//g, '/ldraw/parts/');\n                            } else {\n                                // Handle subparts in s/ directory\n                                normalized = normalized.replace(/\\/ldraw\\/parts\\/parts\\/s\\//g, '/ldraw/parts/s/');\n                                normalized = normalized.replace(/\\/ldraw\\/p\\/parts\\/s\\//g, '/ldraw/parts/s/');\n                                normalized = normalized.replace(/\\/output\\/parts\\/s\\//g, '/ldraw/parts/s/');\n                            }\n                            // console.log('Normalized URL:', normalized);\n                            return normalized;\n                        }\n                    }\n                    // If no valid prefix found, try to construct the path\n                    // This handles cases where the URL is just a filename or relative path\n                    if (!normalized.startsWith('/ldraw/')) {\n                        // Handle subparts (files in s/ directory)\n                        if (hasSubdir) {\n                            normalized = \"/ldraw/parts/s/\".concat(filename);\n                        } else if (filename.match(/^\\d/) || filename.startsWith('stud') || filename.startsWith('edge')) {\n                            normalized = \"/ldraw/p/\".concat(filename);\n                        } else if (filename.endsWith('.dat')) {\n                            normalized = \"/ldraw/parts/\".concat(filename);\n                        } else if (filename.endsWith('.ldr') || filename.endsWith('.mpd')) {\n                            normalized = \"/output/\".concat(filename);\n                        }\n                    // console.log('Constructed URL:', normalized);\n                    }\n                    return normalized;\n                }\n            }[\"LDRViewerComponent.useEffect\"]);\n            loadingManagerRef.current = manager;\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    manager.setURLModifier(undefined);\n                    loadingManagerRef.current = null;\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            if (!containerRef.current || isInitializedRef.current) return;\n            isInitializedRef.current = true;\n            const container = containerRef.current;\n            const width = container.clientWidth;\n            const height = container.clientHeight;\n            const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n            scene.background = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xeeeeee);\n            sceneRef.current = scene;\n            // Camera with settings optimized for large LEGO models\n            const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(45, width / height, 0.1, 100000);\n            camera.position.set(300, 400, 700);\n            cameraRef.current = camera;\n            const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n                antialias: true\n            });\n            renderer.setSize(width, height);\n            renderer.setPixelRatio(window.devicePixelRatio);\n            container.appendChild(renderer.domElement);\n            rendererRef.current = renderer;\n            const controls = new three_examples_jsm_controls_OrbitControls_js__WEBPACK_IMPORTED_MODULE_3__.OrbitControls(camera, renderer.domElement);\n            controls.enableDamping = true;\n            controls.dampingFactor = 0.05;\n            controls.enablePan = true;\n            controls.enableRotate = true;\n            controls.enableZoom = true;\n            controls.screenSpacePanning = false;\n            controls.minDistance = 10;\n            controls.maxDistance = 50000; // Greatly increased max zoom out distance\n            controls.target.set(0, 0, 0);\n            controlsRef.current = controls;\n            // Enhanced lighting for better visibility\n            scene.add(new three__WEBPACK_IMPORTED_MODULE_2__.AmbientLight(0xffffff, 0.9)); // Brighter ambient light\n            // Main directional light\n            const dirLight = new three__WEBPACK_IMPORTED_MODULE_2__.DirectionalLight(0xffffff, 1.0);\n            dirLight.position.set(500, 1000, 500);\n            dirLight.castShadow = false;\n            scene.add(dirLight);\n            // Additional fill lights from different angles\n            const fillLight1 = new three__WEBPACK_IMPORTED_MODULE_2__.DirectionalLight(0xffffff, 0.5);\n            fillLight1.position.set(-500, 500, -500);\n            scene.add(fillLight1);\n            const fillLight2 = new three__WEBPACK_IMPORTED_MODULE_2__.DirectionalLight(0xffffff, 0.5);\n            fillLight2.position.set(500, 500, -500);\n            scene.add(fillLight2);\n            // Add a hemisphere light for more natural lighting\n            const hemiLight = new three__WEBPACK_IMPORTED_MODULE_2__.HemisphereLight(0xffffff, 0xcccccc, 0.4);\n            hemiLight.position.set(0, 500, 0);\n            scene.add(hemiLight);\n            // Grid helper removed\n            // const gridHelper = new THREE.GridHelper(1000, 20);\n            // scene.add(gridHelper);\n            // Add axes helper\n            const axesHelper = new three__WEBPACK_IMPORTED_MODULE_2__.AxesHelper(500);\n            scene.add(axesHelper);\n            const handleResize = {\n                \"LDRViewerComponent.useEffect.handleResize\": ()=>{\n                    if (!containerRef.current || !cameraRef.current || !rendererRef.current) return;\n                    const w = containerRef.current.clientWidth;\n                    const h = containerRef.current.clientHeight;\n                    rendererRef.current.setSize(w, h);\n                    cameraRef.current.aspect = w / h;\n                    cameraRef.current.updateProjectionMatrix();\n                }\n            }[\"LDRViewerComponent.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            // Animation loop is now handled in the cube effect\n            console.log('Scene initialized');\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                // Keep renderer intact but clean up event listener\n                // if (rendererRef.current && containerRef.current) {\n                //   containerRef.current.removeChild(rendererRef.current.domElement);\n                //   rendererRef.current.dispose();\n                // }\n                // isInitializedRef.current = false;\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    // Animation loop - using useRef to ensure single instance\n    const animationIdRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isAnimatingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !controlsRef.current) return;\n            // Prevent multiple animation loops\n            if (isAnimatingRef.current) {\n                console.log('Animation already running, skipping...');\n                return;\n            }\n            // Commented out cancellation\n            // if (animationIdRef.current !== null) {\n            //   cancelAnimationFrame(animationIdRef.current);\n            // }\n            isAnimatingRef.current = true;\n            const animate = {\n                \"LDRViewerComponent.useEffect.animate\": ()=>{\n                    if (!isAnimatingRef.current) return;\n                    // Check all refs before scheduling next frame\n                    if (!controlsRef.current || !rendererRef.current || !sceneRef.current || !cameraRef.current) {\n                        console.warn('Animation loop stopped: missing refs');\n                        isAnimatingRef.current = false;\n                        return;\n                    }\n                    animationIdRef.current = requestAnimationFrame(animate);\n                    try {\n                        // Only validate scene if we've had recent errors\n                        if (errorCountRef.current > 0 && errorCountRef.current < 5) {\n                            let hasNullChildren = false;\n                            let nullCheckCount = 0;\n                            sceneRef.current.traverse({\n                                \"LDRViewerComponent.useEffect.animate\": (child)=>{\n                                    nullCheckCount++;\n                                    // Check if the object itself has required properties\n                                    if (!child.hasOwnProperty('visible')) {\n                                        console.error('Object missing visible property:', child);\n                                    }\n                                    if (child.children) {\n                                        for(let i = 0; i < child.children.length; i++){\n                                            if (child.children[i] === null || child.children[i] === undefined) {\n                                                console.error('Found null/undefined child in scene at index', i, 'of parent:', child);\n                                                hasNullChildren = true;\n                                                // Remove the null child\n                                                child.children.splice(i, 1);\n                                                i--; // Adjust index after removal\n                                            }\n                                        }\n                                    }\n                                }\n                            }[\"LDRViewerComponent.useEffect.animate\"]);\n                            if (hasNullChildren) {\n                                console.warn('Cleaned null children from scene graph after checking', nullCheckCount, 'objects');\n                            }\n                        }\n                        // Update controls and render\n                        // Validate controls state before updating\n                        if (controlsRef.current) {\n                            // Check if controls target is valid\n                            if (!isFinite(controlsRef.current.target.x) || !isFinite(controlsRef.current.target.y) || !isFinite(controlsRef.current.target.z)) {\n                                console.warn('OrbitControls target became invalid, resetting to origin');\n                                controlsRef.current.target.set(0, 0, 0);\n                            }\n                            controlsRef.current.update();\n                        }\n                        // Clean up any null objects in the scene before rendering\n                        const cleanupNullObjects = {\n                            \"LDRViewerComponent.useEffect.animate.cleanupNullObjects\": (obj)=>{\n                                if (!obj || !obj.children) return;\n                                // Filter out null/undefined children\n                                const validChildren = [];\n                                for(let i = 0; i < obj.children.length; i++){\n                                    const child = obj.children[i];\n                                    if (child !== null && child !== undefined && child.visible !== undefined) {\n                                        validChildren.push(child);\n                                        cleanupNullObjects(child); // Recursively clean children\n                                    }\n                                }\n                                // Only update if we removed something\n                                if (validChildren.length !== obj.children.length) {\n                                    obj.children = validChildren;\n                                }\n                            }\n                        }[\"LDRViewerComponent.useEffect.animate.cleanupNullObjects\"];\n                        if (sceneRef.current) {\n                            cleanupNullObjects(sceneRef.current);\n                        }\n                        rendererRef.current.render(sceneRef.current, cameraRef.current);\n                        // Reset error counter on successful render\n                        if (errorCountRef.current > 0) {\n                            console.log('Rendering recovered after', errorCountRef.current, 'errors');\n                            errorCountRef.current = 0;\n                        }\n                    } catch (error) {\n                        errorCountRef.current = (errorCountRef.current || 0) + 1;\n                        if (errorCountRef.current === 1) {\n                            // Only log detailed info on first error\n                            console.error('First error in animation loop:', error);\n                            console.error('Scene children count:', sceneRef.current.children.length);\n                            console.error('Scene state:', sceneRef.current);\n                            console.error('Camera state:', cameraRef.current);\n                            console.error('Controls state:', controlsRef.current);\n                            // Log the model group state\n                            if (modelGroupRef.current) {\n                                console.error('Model group state:', modelGroupRef.current);\n                                console.error('Model visible:', modelGroupRef.current.visible);\n                                console.error('Model children count:', modelGroupRef.current.children.length);\n                            }\n                        }\n                        // Stop animation after too many errors\n                        if (errorCountRef.current > 100) {\n                            console.error('Too many render errors, stopping animation loop');\n                            isAnimatingRef.current = false;\n                        }\n                    }\n                }\n            }[\"LDRViewerComponent.useEffect.animate\"];\n            // Start the animation loop\n            animate();\n            console.log('Animation loop started');\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    // Properly clean up animation loop\n                    isAnimatingRef.current = false;\n                    if (animationIdRef.current !== null) {\n                        cancelAnimationFrame(animationIdRef.current);\n                        animationIdRef.current = null;\n                    }\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    // Test cube commented out - LEGO model should load instead\n    /*\r\n  const cubeRef = useRef<THREE.Mesh | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!sceneRef.current) return;\r\n\r\n    // Prevent adding cube multiple times\r\n    if (cubeRef.current) return;\r\n\r\n    // Add a simple red cube that we know works\r\n    const geometry = new THREE.BoxGeometry(30, 30, 30);\r\n    const material = new THREE.MeshPhongMaterial({\r\n      color: 0xff0000,\r\n      side: THREE.DoubleSide\r\n    });\r\n    const cube = new THREE.Mesh(geometry, material);\r\n    cube.position.set(0, 300, 0);\r\n\r\n    sceneRef.current.add(cube);\r\n\r\n    cubeRef.current = cube;\r\n    console.log('Simple test cube added at:', cube.position);\r\n    console.log('Scene now has', sceneRef.current.children.length, 'children');\r\n\r\n    return () => {\r\n      // Commented out cleanup to keep the cube visible\r\n      // if (sceneRef.current && cube) {\r\n      //   sceneRef.current.remove(cube);  // Also need to prevent removal from scene\r\n      //   geometry.dispose();\r\n      //   material.dispose();\r\n      // }\r\n      // cubeRef.current = null;\r\n    };\r\n  }, []);\r\n  */ // Cube animation commented out since cube is removed\n    /*\r\n  useEffect(() => {\r\n    const animate = () => {\r\n      if (cubeRef.current) {\r\n        cubeRef.current.rotation.x += 0.01;\r\n        cubeRef.current.rotation.y += 0.01;\r\n      }\r\n    };\r\n\r\n    const id = setInterval(animate, 16); // ~60fps\r\n\r\n    // Commented out interval cleanup\r\n    // return () => clearInterval(id);\r\n    return () => {};\r\n  }, []);\r\n  */ // LEGO LOADING CODE\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            // Need either modelPath or ldrawContent\n            if (!modelPath && !ldrawContent || !sceneRef.current || !rendererRef.current || !cameraRef.current) return;\n            // Skip if we're already loading this exact model\n            const currentIdentifier = ldrawContent ? \"content-\".concat(ldrawContent.substring(0, 100)) : modelPath;\n            if (currentModelPathRef.current === currentIdentifier && isLoadingRef.current) {\n                console.log('Same model already loading, skipping...');\n                return;\n            }\n            // Skip if this model is already loaded\n            if (currentModelPathRef.current === currentIdentifier && modelGroupRef.current) {\n                console.log('Model already loaded, skipping...');\n                return;\n            }\n            // Prevent concurrent loads\n            if (isLoadingRef.current) {\n                console.log('Another model is loading, skipping...');\n                return;\n            }\n            // Save camera state before removing model if preserveCamera is true\n            if (preserveCamera && cameraRef.current && controlsRef.current) {\n                savedCameraPosition.current = cameraRef.current.position.clone();\n                savedCameraTarget.current = controlsRef.current.target.clone();\n                console.log('Saved camera position:', savedCameraPosition.current);\n                console.log('Saved camera target:', savedCameraTarget.current);\n            }\n            // Clean up previous model safely\n            if (modelGroupRef.current && sceneRef.current) {\n                console.log('Removing previous model from scene');\n                // Mark as invisible first to prevent render issues\n                modelGroupRef.current.visible = false;\n                // Remove from scene on next tick\n                const modelToRemove = modelGroupRef.current;\n                modelGroupRef.current = null;\n                setTimeout({\n                    \"LDRViewerComponent.useEffect\": ()=>{\n                        if (sceneRef.current && modelToRemove) {\n                            console.log('Actually removing model and disposing resources');\n                            sceneRef.current.remove(modelToRemove);\n                            // Dispose of geometries and materials if needed\n                            modelToRemove.traverse({\n                                \"LDRViewerComponent.useEffect\": (child)=>{\n                                    if (child.geometry) child.geometry.dispose();\n                                    if (child.material) {\n                                        if (Array.isArray(child.material)) {\n                                            child.material.forEach({\n                                                \"LDRViewerComponent.useEffect\": (mat)=>mat.dispose()\n                                            }[\"LDRViewerComponent.useEffect\"]);\n                                        } else {\n                                            child.material.dispose();\n                                        }\n                                    }\n                                }\n                            }[\"LDRViewerComponent.useEffect\"]);\n                            console.log('Model removal complete');\n                        }\n                    }\n                }[\"LDRViewerComponent.useEffect\"], 0);\n            }\n            // Prevent multiple loads of the same model\n            let cancelled = false;\n            isLoadingRef.current = true;\n            currentModelPathRef.current = currentIdentifier || 'generated';\n            // Clear any previous error\n            setLoadError(null);\n            var _loadingManagerRef_current;\n            const loader = new three_examples_jsm_loaders_LDrawLoader_js__WEBPACK_IMPORTED_MODULE_4__.LDrawLoader((_loadingManagerRef_current = loadingManagerRef.current) !== null && _loadingManagerRef_current !== void 0 ? _loadingManagerRef_current : undefined);\n            // Set the parts library path to the ldraw directory\n            loader.setPartsLibraryPath('/ldraw/');\n            // Enable smooth normals for better rendering\n            loader.smoothNormals = true;\n            // Set the file map for better part resolution\n            loader.setFileMap({});\n            // Set the conditional line material class (not an instance)\n            loader.setConditionalLineMaterial(three_examples_jsm_materials_LDrawConditionalLineMaterial_js__WEBPACK_IMPORTED_MODULE_5__.LDrawConditionalLineMaterial);\n            console.log(ldrawContent ? 'Loading LDraw from content' : \"Loading LDR file: \".concat(modelPath));\n            // Try to preload materials first, but don't fail if it doesn't work\n            const materialsPromise = loader.preloadMaterials('/ldraw/LDConfig.ldr').then({\n                \"LDRViewerComponent.useEffect.materialsPromise\": ()=>{\n                    console.log('Materials preloaded successfully');\n                }\n            }[\"LDRViewerComponent.useEffect.materialsPromise\"]).catch({\n                \"LDRViewerComponent.useEffect.materialsPromise\": (err)=>{\n                    console.warn('Could not preload materials, using defaults:', err.message);\n                }\n            }[\"LDRViewerComponent.useEffect.materialsPromise\"]);\n            // Override console.warn to catch subobject loading errors\n            const originalWarn = console.warn;\n            let hasSubobjectError = false;\n            console.warn = ({\n                \"LDRViewerComponent.useEffect\": function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    const message = args.join(' ');\n                    if (message.includes('could not be loaded') || message.includes('Subobject')) {\n                        hasSubobjectError = true;\n                        // Don't log the warning to console\n                        return;\n                    }\n                    originalWarn.apply(console, args);\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n            // Load the model (wait for materials if possible, but don't block)\n            materialsPromise.finally({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    if (cancelled) return;\n                    // If we have direct content, parse it; otherwise load from file\n                    let modelPromise;\n                    if (ldrawContent) {\n                        // Use parse with callbacks and wrap in a promise\n                        modelPromise = new Promise({\n                            \"LDRViewerComponent.useEffect\": (resolve)=>{\n                                loader.parse(ldrawContent, {\n                                    \"LDRViewerComponent.useEffect\": (group)=>resolve(group)\n                                }[\"LDRViewerComponent.useEffect\"], {\n                                    \"LDRViewerComponent.useEffect\": (error)=>{\n                                        console.error('Error parsing LDraw content:', error);\n                                        resolve(null);\n                                    }\n                                }[\"LDRViewerComponent.useEffect\"]);\n                            }\n                        }[\"LDRViewerComponent.useEffect\"]);\n                    } else if (modelPath) {\n                        modelPromise = loader.loadAsync(modelPath).catch({\n                            \"LDRViewerComponent.useEffect\": (error)=>{\n                                console.error('Error loading model:', error);\n                                return null;\n                            }\n                        }[\"LDRViewerComponent.useEffect\"]);\n                    } else {\n                        modelPromise = Promise.resolve(null);\n                    }\n                    modelPromise.then({\n                        \"LDRViewerComponent.useEffect\": (group)=>{\n                            var _sceneRef_current;\n                            // Restore original console.warn\n                            console.warn = originalWarn;\n                            if (!group || cancelled) return;\n                            // Check if there were subobject errors\n                            if (hasSubobjectError) {\n                                console.log('Model has missing parts, displaying as error');\n                                throw new Error('Missing parts - model cannot be rendered properly');\n                            }\n                            console.log('Model loaded successfully:', group);\n                            isLoadingRef.current = false;\n                            // Safe traversal to handle null objects - remove them completely\n                            const safeTraverse = {\n                                \"LDRViewerComponent.useEffect.safeTraverse\": (obj)=>{\n                                    // Skip if null or undefined\n                                    if (!obj) return;\n                                    // Skip if not a valid object\n                                    if (typeof obj !== 'object') return;\n                                    // Skip if doesn't have visible property (not a Three.js object)\n                                    if (!('visible' in obj)) return;\n                                    // Process this object\n                                    if (obj.isMesh) {\n                                        const mesh = obj;\n                                        if (!mesh.material) {\n                                            // Create a default material if missing\n                                            mesh.material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhongMaterial({\n                                                color: 0x808080,\n                                                side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n                                            });\n                                            console.log('Added default material to mesh:', mesh.name);\n                                        } else if (Array.isArray(mesh.material)) {\n                                            // Check array of materials\n                                            mesh.material = mesh.material.map({\n                                                \"LDRViewerComponent.useEffect.safeTraverse\": (mat)=>{\n                                                    if (!mat) {\n                                                        console.log('Replacing null material in array');\n                                                        return new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhongMaterial({\n                                                            color: 0x808080,\n                                                            side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n                                                        });\n                                                    }\n                                                    return mat;\n                                                }\n                                            }[\"LDRViewerComponent.useEffect.safeTraverse\"]);\n                                        }\n                                    }\n                                    // Remove null children completely\n                                    if (obj.children && Array.isArray(obj.children)) {\n                                        const validChildren = [];\n                                        for (const child of obj.children){\n                                            // Only keep valid children\n                                            if (child && typeof child === 'object' && 'visible' in child) {\n                                                validChildren.push(child);\n                                                safeTraverse(child);\n                                            } else if (child) {\n                                                console.warn('Removing invalid child from model:', child);\n                                            }\n                                        }\n                                        // Replace children array with only valid ones\n                                        obj.children = validChildren;\n                                    }\n                                }\n                            }[\"LDRViewerComponent.useEffect.safeTraverse\"];\n                            safeTraverse(group);\n                            // Skip step parsing for now - just add the model as-is\n                            /*\r\n        // Parse STEP commands from the LDraw content if available\r\n        let stepBoundaries: number[] = [];\r\n        if (content) {\r\n          const lines = content.split('\\n');\r\n          let partCount = 0;\r\n          lines.forEach(line => {\r\n            const trimmed = line.trim();\r\n            if (trimmed.startsWith('1 ')) {\r\n              // This is a part line\r\n              partCount++;\r\n            } else if (trimmed === '0 STEP' || trimmed.toLowerCase() === '0 step') {\r\n              // This is a STEP command\r\n              stepBoundaries.push(partCount);\r\n              console.log(`Found STEP command after part ${partCount}`);\r\n            }\r\n          });\r\n          if (stepBoundaries.length > 0) {\r\n            console.log(`Found ${stepBoundaries.length} STEP commands in model`);\r\n          }\r\n        }\r\n\r\n        // Organize model into steps based on STEP commands\r\n        const steps: THREE.Group[] = [];\r\n        const allParts: THREE.Object3D[] = [];\r\n\r\n        // Collect only direct child groups/objects (not nested meshes)\r\n        // Each direct child typically represents one part from the LDraw file\r\n        const collectTopLevelParts = (obj: any, depth: number = 0) => {\r\n          // For the root group, process its direct children\r\n          if (depth === 0) {\r\n            obj.children.forEach((child: any) => {\r\n              // Each direct child is typically a part\r\n              if (child.type === 'Group' || child.type === 'Object3D' || child.isMesh || child.isLine) {\r\n                allParts.push(child);\r\n              }\r\n            });\r\n          }\r\n        };\r\n\r\n        collectTopLevelParts(group);\r\n        console.log(`Found ${allParts.length} top-level parts in model`);\r\n\r\n        // If we have STEP commands, organize parts accordingly\r\n        if (stepBoundaries.length > 0 && allParts.length > 0) {\r\n          const totalSteps = stepBoundaries.length;\r\n          console.log(`Organizing ${allParts.length} parts into ${totalSteps} steps`);\r\n          console.log(`Step boundaries (cumulative part counts): ${stepBoundaries.join(', ')}`);\r\n\r\n          // Assign step numbers to each part\r\n          allParts.forEach((part, index) => {\r\n            // Find which step this part belongs to\r\n            let stepNumber = 1;\r\n            for (let i = 0; i < stepBoundaries.length; i++) {\r\n              if (index < stepBoundaries[i]) {\r\n                stepNumber = i + 1;\r\n                break;\r\n              }\r\n            }\r\n\r\n            // Assign step number to this part and all its children\r\n            part.userData.stepNumber = stepNumber;\r\n            part.traverse((child: any) => {\r\n              child.userData.stepNumber = stepNumber;\r\n            });\r\n          });\r\n\r\n          // Create step groups and add parts to them\r\n          for (let stepNum = 1; stepNum <= totalSteps; stepNum++) {\r\n            const stepGroup = new THREE.Group();\r\n            stepGroup.name = `Step ${stepNum}`;\r\n            let partsInStep = 0;\r\n\r\n            allParts.forEach(part => {\r\n              if (part.userData.stepNumber === stepNum) {\r\n                stepGroup.add(part);\r\n                partsInStep++;\r\n              }\r\n            });\r\n\r\n            if (partsInStep > 0) {\r\n              steps.push(stepGroup);\r\n              console.log(`Step ${stepNum}: ${partsInStep} parts`);\r\n            }\r\n          }\r\n\r\n        } else {\r\n          // No STEP commands found, treat all parts as one step\r\n          console.log('No STEP commands found, treating model as single step');\r\n          const singleStep = new THREE.Group();\r\n          singleStep.name = 'Step 1';\r\n          allParts.forEach(part => {\r\n            part.userData.stepNumber = 1;\r\n            part.traverse((child: any) => {\r\n              child.userData.stepNumber = 1;\r\n            });\r\n            singleStep.add(part);\r\n          });\r\n          if (singleStep.children.length > 0) {\r\n            steps.push(singleStep);\r\n          }\r\n        }\r\n\r\n        // Collect all mesh/line objects for visibility control\r\n        const allRenderables: THREE.Object3D[] = [];\r\n        group.traverse((child: any) => {\r\n          if (child.isMesh || child.isLine || child.isLineSegments) {\r\n            allRenderables.push(child);\r\n          }\r\n        });\r\n\r\n        console.log(`Model organized into ${steps.length} steps with ${allRenderables.length} renderable objects`);\r\n        stepsRef.current = steps;\r\n        allPartsRef.current = allRenderables;\r\n        setTotalSteps(steps.length);\r\n        setCurrentStep(steps.length); // Start with all steps visible\r\n        */ // Position model at origin\n                            group.position.set(0, 0, 0);\n                            group.rotation.x = Math.PI; // Rotation can cause issues, keeping it commented\n                            modelGroupRef.current = group;\n                            if (sceneRef.current) {\n                                sceneRef.current.add(group);\n                                console.log('Model added to scene');\n                                console.log('Group children:', group.children.length);\n                                console.log('Group visible:', group.visible);\n                                console.log('Group in scene:', sceneRef.current.children.includes(group));\n                                // Make sure the group is visible\n                                group.visible = true;\n                                group.traverse({\n                                    \"LDRViewerComponent.useEffect\": (child)=>{\n                                        child.visible = true;\n                                    }\n                                }[\"LDRViewerComponent.useEffect\"]);\n                                // Count visible meshes and check materials\n                                let meshCount = 0;\n                                let visibleCount = 0;\n                                group.traverse({\n                                    \"LDRViewerComponent.useEffect\": (child)=>{\n                                        if (child.isMesh) {\n                                            var _mesh_geometry_attributes_position;\n                                            meshCount++;\n                                            const mesh = child;\n                                            if (mesh.visible) visibleCount++;\n                                            if (!mesh.geometry.boundingBox) {\n                                                mesh.geometry.computeBoundingBox();\n                                            }\n                                            // Log mesh details\n                                            console.log('Mesh details:', {\n                                                name: mesh.name,\n                                                visible: mesh.visible,\n                                                material: mesh.material,\n                                                geometryVertices: ((_mesh_geometry_attributes_position = mesh.geometry.attributes.position) === null || _mesh_geometry_attributes_position === void 0 ? void 0 : _mesh_geometry_attributes_position.count) || 0,\n                                                position: mesh.position,\n                                                scale: mesh.scale\n                                            });\n                                            // Make sure mesh has a material\n                                            if (!mesh.material) {\n                                                console.warn('Mesh has no material, adding default');\n                                                mesh.material = new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhongMaterial({\n                                                    color: 0xff0000,\n                                                    side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide\n                                                });\n                                            }\n                                        }\n                                    }\n                                }[\"LDRViewerComponent.useEffect\"]);\n                                console.log(\"Found \".concat(meshCount, \" meshes, \").concat(visibleCount, \" visible\"));\n                            // Test cube removed - rendering verified to be working\n                            // const testGeometry = new THREE.BoxGeometry(50, 50, 50);\n                            // const testMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });\n                            // const testCube = new THREE.Mesh(testGeometry, testMaterial);\n                            // testCube.position.set(100, 25, 0);\n                            // sceneRef.current.add(testCube);\n                            // console.log('Test cube added at:', testCube.position);\n                            }\n                            // Force update matrices before calculating bounding box\n                            group.updateMatrixWorld(true);\n                            // Calculate bounding box and center camera\n                            const box = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(group);\n                            const center = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n                            const size = box.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n                            // Log model information\n                            if (!box.isEmpty() && size.x > 0 && size.y > 0 && size.z > 0) {\n                                console.log('Model center:', center.x, center.y, center.z);\n                                console.log('Model size:', size.x, size.y, size.z);\n                            } else {\n                                console.warn('Model has empty/invalid bounding box');\n                            }\n                            if (controlsRef.current && cameraRef.current) {\n                                // Restore camera position if preserveCamera is true and we have saved state\n                                if (preserveCamera && savedCameraPosition.current && savedCameraTarget.current) {\n                                    console.log('Restoring camera position');\n                                    cameraRef.current.position.copy(savedCameraPosition.current);\n                                    controlsRef.current.target.copy(savedCameraTarget.current);\n                                } else {\n                                    // Just update controls to look at origin for initial load\n                                    controlsRef.current.target.set(0, 0, 0);\n                                }\n                                controlsRef.current.update();\n                            }\n                            // The animation loop will handle rendering\n                            console.log('Scene children:', ((_sceneRef_current = sceneRef.current) === null || _sceneRef_current === void 0 ? void 0 : _sceneRef_current.children.length) || 0);\n                        }\n                    }[\"LDRViewerComponent.useEffect\"]).catch({\n                        \"LDRViewerComponent.useEffect\": (error)=>{\n                            // Restore original console.warn in case of error\n                            console.warn = originalWarn;\n                            if (cancelled) return;\n                            console.error('Error loading model:', error);\n                            console.error('Model path:', modelPath);\n                            console.error('Stack trace:', error.stack);\n                            isLoadingRef.current = false;\n                            // Set error message for display\n                            let errorMessage = 'Build failed to render';\n                            if (error.message) {\n                                // Check if it's a missing parts error\n                                if (error.message.includes('Missing parts')) {\n                                    errorMessage = 'Cannot be rendered\\nMissing LEGO parts';\n                                } else {\n                                    // Extract the specific part that failed if available\n                                    const partMatch = error.message.match(/\"([^\"]+\\.dat)\"/);\n                                    if (partMatch) {\n                                        errorMessage = \"Build failed to render\\nInvalid part: \".concat(partMatch[1]);\n                                    }\n                                }\n                            }\n                            setLoadError(errorMessage);\n                        }\n                    }[\"LDRViewerComponent.useEffect\"]);\n                }\n            }[\"LDRViewerComponent.useEffect\"]); // Close the .finally() block\n            // Cleanup function - only remove model if path changes or component unmounts\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    cancelled = true;\n                    // Restore original console.warn if it's been overridden\n                    if (console.warn !== originalWarn) {\n                        console.warn = originalWarn;\n                    }\n                // Don't clear the model here - it will be cleared when a new model loads\n                // or when the component unmounts\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], [\n        modelPath,\n        ldrawContent\n    ]);\n    // Clean up model when component unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            return ({\n                \"LDRViewerComponent.useEffect\": ()=>{\n                    if (modelGroupRef.current && sceneRef.current) {\n                        // Mark as invisible first\n                        modelGroupRef.current.visible = false;\n                        // Then remove\n                        sceneRef.current.remove(modelGroupRef.current);\n                        modelGroupRef.current = null;\n                    }\n                    isLoadingRef.current = false;\n                    currentModelPathRef.current = '';\n                }\n            })[\"LDRViewerComponent.useEffect\"];\n        }\n    }[\"LDRViewerComponent.useEffect\"], []);\n    // Update visibility based on current step\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LDRViewerComponent.useEffect\": ()=>{\n            if (allPartsRef.current.length === 0) return;\n            console.log(\"Updating visibility for step \".concat(currentStep, \" of \").concat(totalSteps));\n            // Show/hide parts based on current step\n            allPartsRef.current.forEach({\n                \"LDRViewerComponent.useEffect\": (part)=>{\n                    const partStep = part.userData.stepNumber || 1;\n                    part.visible = partStep <= currentStep;\n                }\n            }[\"LDRViewerComponent.useEffect\"]);\n        }\n    }[\"LDRViewerComponent.useEffect\"], [\n        currentStep,\n        totalSteps\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: 'relative',\n            width: '100%'\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: containerRef,\n                style: {\n                    width: '100%',\n                    height: '600px',\n                    border: '1px solid #ccc',\n                    borderRadius: '8px',\n                    overflow: 'hidden',\n                    position: 'relative'\n                },\n                children: loadError && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: 'absolute',\n                        top: '50%',\n                        left: '50%',\n                        transform: 'translate(-50%, -50%)',\n                        backgroundColor: 'rgba(255, 255, 255, 0.95)',\n                        padding: '20px 30px',\n                        borderRadius: '8px',\n                        boxShadow: '0 2px 10px rgba(0, 0, 0, 0.1)',\n                        textAlign: 'center',\n                        zIndex: 100\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                color: '#d32f2f',\n                                fontSize: '18px',\n                                fontWeight: '600',\n                                marginBottom: '8px'\n                            },\n                            children: [\n                                \" \",\n                                loadError.split('\\n')[0]\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                            lineNumber: 947,\n                            columnNumber: 13\n                        }, undefined),\n                        loadError.includes('\\n') && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                color: '#666',\n                                fontSize: '14px',\n                                marginTop: '8px'\n                            },\n                            children: loadError.split('\\n')[1]\n                        }, void 0, false, {\n                            fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                            lineNumber: 958,\n                            columnNumber: 15\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                    lineNumber: 933,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                lineNumber: 921,\n                columnNumber: 7\n            }, undefined),\n            totalSteps > 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: 'absolute',\n                    bottom: '20px',\n                    left: '50%',\n                    transform: 'translateX(-50%)',\n                    backgroundColor: 'rgba(255, 255, 255, 0.95)',\n                    padding: '15px 20px',\n                    borderRadius: '8px',\n                    boxShadow: '0 2px 10px rgba(0,0,0,0.2)',\n                    display: 'flex',\n                    alignItems: 'center',\n                    gap: '15px',\n                    minWidth: '400px',\n                    zIndex: 1000\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        style: {\n                            fontWeight: 'bold',\n                            fontSize: '14px',\n                            color: '#333',\n                            minWidth: '80px'\n                        },\n                        children: [\n                            \"Step \",\n                            currentStep,\n                            \"/\",\n                            totalSteps\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                        lineNumber: 987,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"range\",\n                        min: 1,\n                        max: totalSteps,\n                        value: currentStep,\n                        onChange: (e)=>setCurrentStep(parseInt(e.target.value)),\n                        style: {\n                            flex: 1,\n                            height: '6px',\n                            background: \"linear-gradient(to right, #4CAF50 0%, #4CAF50 \".concat((currentStep - 1) / (totalSteps - 1) * 100, \"%, #ddd \").concat((currentStep - 1) / (totalSteps - 1) * 100, \"%, #ddd 100%)\"),\n                            borderRadius: '3px',\n                            outline: 'none',\n                            cursor: 'pointer'\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                        lineNumber: 995,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: 'flex',\n                            gap: '8px'\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setCurrentStep(Math.max(1, currentStep - 1)),\n                                disabled: currentStep <= 1,\n                                style: {\n                                    padding: '6px 12px',\n                                    backgroundColor: currentStep > 1 ? '#4CAF50' : '#ccc',\n                                    color: 'white',\n                                    border: 'none',\n                                    borderRadius: '4px',\n                                    cursor: currentStep > 1 ? 'pointer' : 'not-allowed',\n                                    fontSize: '12px',\n                                    fontWeight: 'bold'\n                                },\n                                children: \" Prev\"\n                            }, void 0, false, {\n                                fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                                lineNumber: 1014,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setCurrentStep(Math.min(totalSteps, currentStep + 1)),\n                                disabled: currentStep >= totalSteps,\n                                style: {\n                                    padding: '6px 12px',\n                                    backgroundColor: currentStep < totalSteps ? '#4CAF50' : '#ccc',\n                                    color: 'white',\n                                    border: 'none',\n                                    borderRadius: '4px',\n                                    cursor: currentStep < totalSteps ? 'pointer' : 'not-allowed',\n                                    fontSize: '12px',\n                                    fontWeight: 'bold'\n                                },\n                                children: \"Next \"\n                            }, void 0, false, {\n                                fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                                lineNumber: 1030,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setCurrentStep(currentStep === totalSteps ? 1 : totalSteps),\n                                style: {\n                                    padding: '6px 12px',\n                                    backgroundColor: '#2196F3',\n                                    color: 'white',\n                                    border: 'none',\n                                    borderRadius: '4px',\n                                    cursor: 'pointer',\n                                    fontSize: '12px',\n                                    fontWeight: 'bold'\n                                },\n                                children: currentStep === totalSteps ? 'Reset' : 'All'\n                            }, void 0, false, {\n                                fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                                lineNumber: 1046,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                        lineNumber: 1010,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n                lineNumber: 972,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/gnome/lego/brickyard/components/LDRViewer.tsx\",\n        lineNumber: 920,\n        columnNumber: 5\n    }, undefined);\n};\n_s(LDRViewerComponent, \"sdjX9Y5L7+TurB1ObkNBvCF6Y7s=\");\n_c = LDRViewerComponent;\nconst LDRViewer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(LDRViewerComponent);\n_c1 = LDRViewer;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LDRViewer);\nvar _c, _c1;\n$RefreshReg$(_c, \"LDRViewerComponent\");\n$RefreshReg$(_c1, \"LDRViewer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvTERSVmlld2VyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUN4QjtBQUM4QztBQUNMO0FBQ29DO0FBUTVHLE1BQU1RLHFCQUErQztRQUFDLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFQyxjQUFjLEVBQUU7O0lBQy9GLE1BQU1DLGVBQWVWLDZDQUFNQSxDQUFpQjtJQUM1QyxNQUFNVyxXQUFXWCw2Q0FBTUEsQ0FBcUI7SUFDNUMsTUFBTVksY0FBY1osNkNBQU1BLENBQTZCO0lBQ3ZELE1BQU1hLFlBQVliLDZDQUFNQSxDQUFpQztJQUN6RCxNQUFNYyxjQUFjZCw2Q0FBTUEsQ0FBdUI7SUFDakQsTUFBTWUsZ0JBQWdCZiw2Q0FBTUEsQ0FBcUI7SUFDakQsTUFBTWdCLG9CQUFvQmhCLDZDQUFNQSxDQUE4QjtJQUM5RCxNQUFNaUIsZUFBZWpCLDZDQUFNQSxDQUFVO0lBQ3JDLE1BQU1rQixzQkFBc0JsQiw2Q0FBTUEsQ0FBUztJQUMzQyxNQUFNbUIsbUJBQW1CbkIsNkNBQU1BLENBQVU7SUFDekMsTUFBTW9CLGdCQUFnQnBCLDZDQUFNQSxDQUFTO0lBRXJDLHNDQUFzQztJQUN0QyxNQUFNLENBQUNxQixXQUFXQyxhQUFhLEdBQUd4QixxREFBYyxDQUFnQjtJQUVoRSw0QkFBNEI7SUFDNUIsTUFBTTBCLHNCQUFzQnhCLDZDQUFNQSxDQUF1QjtJQUN6RCxNQUFNeUIsb0JBQW9CekIsNkNBQU1BLENBQXVCO0lBRXZELGVBQWU7SUFDZixNQUFNLENBQUMwQixhQUFhQyxlQUFlLEdBQUc3QixxREFBYyxDQUFTO0lBQzdELE1BQU0sQ0FBQzhCLFlBQVlDLGNBQWMsR0FBRy9CLHFEQUFjLENBQVM7SUFDM0QsTUFBTWdDLFdBQVc5Qiw2Q0FBTUEsQ0FBZ0IsRUFBRTtJQUN6QyxNQUFNK0IsY0FBYy9CLDZDQUFNQSxDQUFtQixFQUFFO0lBRS9DLG1DQUFtQztJQUNuQ0QsZ0RBQVNBO3dDQUFD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aE0sY0FBYyxJQUFJLFlBQVk7b0NBQy9DcUosT0FBTztvQ0FDUHFDLFFBQVE7b0NBQ1JDLGNBQWM7b0NBQ2Q4QixRQUFRek4sY0FBYyxJQUFJLFlBQVk7b0NBQ3RDcU0sVUFBVTtvQ0FDVkMsWUFBWTtnQ0FDZDswQ0FDRDs7Ozs7OzBDQUdELDhEQUFDb0I7Z0NBQ0NDLFNBQVMsSUFBTTFOLGVBQWUwSixLQUFLc0QsR0FBRyxDQUFDL00sWUFBWUYsY0FBYztnQ0FDakU0TixVQUFVNU4sZUFBZUU7Z0NBQ3pCc0wsT0FBTztvQ0FDTFMsU0FBUztvQ0FDVEQsaUJBQWlCaE0sY0FBY0UsYUFBYSxZQUFZO29DQUN4RG1KLE9BQU87b0NBQ1BxQyxRQUFRO29DQUNSQyxjQUFjO29DQUNkOEIsUUFBUXpOLGNBQWNFLGFBQWEsWUFBWTtvQ0FDL0NtTSxVQUFVO29DQUNWQyxZQUFZO2dDQUNkOzBDQUNEOzs7Ozs7MENBR0QsOERBQUNvQjtnQ0FDQ0MsU0FBUyxJQUFNMU4sZUFBZUQsZ0JBQWdCRSxhQUFhLElBQUlBO2dDQUMvRHNMLE9BQU87b0NBQ0xTLFNBQVM7b0NBQ1RELGlCQUFpQjtvQ0FDakIzQyxPQUFPO29DQUNQcUMsUUFBUTtvQ0FDUkMsY0FBYztvQ0FDZDhCLFFBQVE7b0NBQ1JwQixVQUFVO29DQUNWQyxZQUFZO2dDQUNkOzBDQUVDdE0sZ0JBQWdCRSxhQUFhLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU90RDtHQTdoQ010QjtLQUFBQTtBQStoQ04sTUFBTWlQLDBCQUFZdFAsMkNBQUlBLENBQUNLOztBQUN2QixpRUFBZWlQLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9nbm9tZS9sZWdvL2JyaWNreWFyZC9jb21wb25lbnRzL0xEUlZpZXdlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XHJcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scy5qcyc7XHJcbmltcG9ydCB7IExEcmF3TG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvTERyYXdMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBMRHJhd0NvbmRpdGlvbmFsTGluZU1hdGVyaWFsIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL21hdGVyaWFscy9MRHJhd0NvbmRpdGlvbmFsTGluZU1hdGVyaWFsLmpzJztcclxuXHJcbmludGVyZmFjZSBMRFJWaWV3ZXJQcm9wcyB7XHJcbiAgbW9kZWxQYXRoPzogc3RyaW5nO1xyXG4gIGxkcmF3Q29udGVudD86IHN0cmluZztcclxuICBwcmVzZXJ2ZUNhbWVyYT86IGJvb2xlYW47XHJcbn1cclxuXHJcbmNvbnN0IExEUlZpZXdlckNvbXBvbmVudDogUmVhY3QuRkM8TERSVmlld2VyUHJvcHM+ID0gKHsgbW9kZWxQYXRoLCBsZHJhd0NvbnRlbnQsIHByZXNlcnZlQ2FtZXJhIH0pID0+IHtcclxuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IHNjZW5lUmVmID0gdXNlUmVmPFRIUkVFLlNjZW5lIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgcmVuZGVyZXJSZWYgPSB1c2VSZWY8VEhSRUUuV2ViR0xSZW5kZXJlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGNhbWVyYVJlZiA9IHVzZVJlZjxUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGNvbnRyb2xzUmVmID0gdXNlUmVmPE9yYml0Q29udHJvbHMgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBtb2RlbEdyb3VwUmVmID0gdXNlUmVmPFRIUkVFLkdyb3VwIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgbG9hZGluZ01hbmFnZXJSZWYgPSB1c2VSZWY8VEhSRUUuTG9hZGluZ01hbmFnZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBpc0xvYWRpbmdSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG4gIGNvbnN0IGN1cnJlbnRNb2RlbFBhdGhSZWYgPSB1c2VSZWY8c3RyaW5nPignJyk7XHJcbiAgY29uc3QgaXNJbml0aWFsaXplZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgZXJyb3JDb3VudFJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG5cclxuICAvLyBFcnJvciBzdGF0ZSBmb3IgZGlzcGxheWluZyBtZXNzYWdlc1xyXG4gIGNvbnN0IFtsb2FkRXJyb3IsIHNldExvYWRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gQ2FtZXJhIHN0YXRlIHByZXNlcnZhdGlvblxyXG4gIGNvbnN0IHNhdmVkQ2FtZXJhUG9zaXRpb24gPSB1c2VSZWY8VEhSRUUuVmVjdG9yMyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHNhdmVkQ2FtZXJhVGFyZ2V0ID0gdXNlUmVmPFRIUkVFLlZlY3RvcjMgfCBudWxsPihudWxsKTtcclxuXHJcbiAgLy8gU3RlcCBjb250cm9sXHJcbiAgY29uc3QgW2N1cnJlbnRTdGVwLCBzZXRDdXJyZW50U3RlcF0gPSBSZWFjdC51c2VTdGF0ZTxudW1iZXI+KDEpO1xyXG4gIGNvbnN0IFt0b3RhbFN0ZXBzLCBzZXRUb3RhbFN0ZXBzXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMSk7XHJcbiAgY29uc3Qgc3RlcHNSZWYgPSB1c2VSZWY8VEhSRUUuR3JvdXBbXT4oW10pO1xyXG4gIGNvbnN0IGFsbFBhcnRzUmVmID0gdXNlUmVmPFRIUkVFLk9iamVjdDNEW10+KFtdKTtcclxuXHJcbiAgLy8gQ3JlYXRlIGxvYWRpbmcgbWFuYWdlciBvbmx5IG9uY2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGxvYWRpbmdNYW5hZ2VyUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBtYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCk7XHJcblxyXG4gICAgLy8gSW1wbGVtZW50IHBhdGggcmVzb2x1dGlvbiBzdHJhdGVneSBzaW1pbGFyIHRvIFRocmVlLmpzIHBhY2tMRHJhd01vZGVsXHJcbiAgICBtYW5hZ2VyLnNldFVSTE1vZGlmaWVyKCh1cmwpID0+IHtcclxuICAgICAgLy8gY29uc29sZS5sb2coJ09yaWdpbmFsIFVSTDonLCB1cmwpO1xyXG5cclxuICAgICAgLy8gTm9ybWFsaXplIHBhdGggc2VwYXJhdG9yc1xyXG4gICAgICBsZXQgbm9ybWFsaXplZCA9IHVybC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcblxyXG4gICAgICAvLyBIYW5kbGUgc1xcIHByZWZpeCBmb3Igc3VicGFydHMgKGNvbnZlcnQgc1xcZmlsZS5kYXQgdG8gcy9maWxlLmRhdClcclxuICAgICAgaWYgKG5vcm1hbGl6ZWQuaW5jbHVkZXMoJ3MvJykgfHwgbm9ybWFsaXplZC5tYXRjaCgvc1tcXFxcXFwvXS8pKSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBub3JtYWxpemVkLnNwbGl0KC9bXFxcXFxcL10vKTtcclxuICAgICAgICBjb25zdCBsYXN0VHdvID0gcGFydHMuc2xpY2UoLTIpO1xyXG4gICAgICAgIGlmIChsYXN0VHdvWzBdID09PSAncycpIHtcclxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBzdWJwYXJ0IHJlZmVyZW5jZVxyXG4gICAgICAgICAgbm9ybWFsaXplZCA9IGAvbGRyYXcvcGFydHMvcy8ke2xhc3RUd29bMV19YDtcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTdWJwYXJ0IGRldGVjdGVkLCBub3JtYWxpemVkIHRvOicsIG5vcm1hbGl6ZWQpO1xyXG4gICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IHRoZSBmaWxlbmFtZSBhbmQgY2hlY2sgZm9yIHN1YmRpcmVjdG9yeSAobGlrZSBzLylcclxuICAgICAgY29uc3QgdXJsUGFydHMgPSBub3JtYWxpemVkLnNwbGl0KCcvJyk7XHJcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gdXJsUGFydHNbdXJsUGFydHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgY29uc3QgaGFzU3ViZGlyID0gdXJsUGFydHMubGVuZ3RoID49IDIgJiYgdXJsUGFydHNbdXJsUGFydHMubGVuZ3RoIC0gMl0gPT09ICdzJztcclxuXHJcbiAgICAgIC8vIERlZmluZSBwb3NzaWJsZSBwYXRoIHByZWZpeGVzIHRvIHRyeVxyXG4gICAgICBjb25zdCBwYXRoUHJlZml4ZXMgPSBbXHJcbiAgICAgICAgJy9vdXRwdXQvJywgICAgICAgICAgLy8gT3V0cHV0IGRpcmVjdG9yeSBmb3IgZ2VuZXJhdGVkIG1vZGVsc1xyXG4gICAgICAgICcvbGRyYXcvJywgICAgICAgICAgIC8vIERpcmVjdCBwYXRoXHJcbiAgICAgICAgJy9sZHJhdy9wLycsICAgICAgICAgLy8gUHJpbWl0aXZlc1xyXG4gICAgICAgICcvbGRyYXcvcGFydHMvJywgICAgIC8vIFBhcnRzXHJcbiAgICAgIF07XHJcblxyXG4gICAgICAvLyBJZiB0aGUgVVJMIGFscmVhZHkgaGFzIGEgdmFsaWQgcHJlZml4LCBjbGVhbiBpdCB1cFxyXG4gICAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwYXRoUHJlZml4ZXMpIHtcclxuICAgICAgICBpZiAobm9ybWFsaXplZC5pbmNsdWRlcyhwcmVmaXgpKSB7XHJcbiAgICAgICAgICAvLyBDbGVhbiB1cCBhbnkgZHVwbGljYXRlIHBhdGggc2VnbWVudHNcclxuICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL1xcL2xkcmF3XFwvcGFydHNcXC9wYXJ0c1xcLy9nLCAnL2xkcmF3L3BhcnRzLycpO1xyXG4gICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvbGRyYXdcXC9wXFwvcFxcLy9nLCAnL2xkcmF3L3AvJyk7XHJcbiAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9cXC9vdXRwdXRcXC9vdXRwdXRcXC8vZywgJy9vdXRwdXQvJyk7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSByZWR1bmRhbnQgcGF0aCBjb21iaW5hdGlvbnMgYnV0IHByZXNlcnZlIHMvIHN1YmRpcmVjdG9yeVxyXG4gICAgICAgICAgaWYgKCFub3JtYWxpemVkLmluY2x1ZGVzKCcvcy8nKSkge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9cXC9sZHJhd1xcL3BhcnRzXFwvcFxcLy9nLCAnL2xkcmF3L3AvJyk7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkLnJlcGxhY2UoL1xcL291dHB1dFxcL3BcXC8vZywgJy9sZHJhdy9wLycpO1xyXG4gICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9cXC9sZHJhd1xcL3BcXC9wYXJ0c1xcLy9nLCAnL2xkcmF3L3BhcnRzLycpO1xyXG4gICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9cXC9vdXRwdXRcXC9wYXJ0c1xcLy9nLCAnL2xkcmF3L3BhcnRzLycpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSGFuZGxlIHN1YnBhcnRzIGluIHMvIGRpcmVjdG9yeVxyXG4gICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5yZXBsYWNlKC9cXC9sZHJhd1xcL3BhcnRzXFwvcGFydHNcXC9zXFwvL2csICcvbGRyYXcvcGFydHMvcy8nKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvbGRyYXdcXC9wXFwvcGFydHNcXC9zXFwvL2csICcvbGRyYXcvcGFydHMvcy8nKTtcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvb3V0cHV0XFwvcGFydHNcXC9zXFwvL2csICcvbGRyYXcvcGFydHMvcy8nKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTm9ybWFsaXplZCBVUkw6Jywgbm9ybWFsaXplZCk7XHJcbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIG5vIHZhbGlkIHByZWZpeCBmb3VuZCwgdHJ5IHRvIGNvbnN0cnVjdCB0aGUgcGF0aFxyXG4gICAgICAvLyBUaGlzIGhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIFVSTCBpcyBqdXN0IGEgZmlsZW5hbWUgb3IgcmVsYXRpdmUgcGF0aFxyXG4gICAgICBpZiAoIW5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnL2xkcmF3LycpKSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIHN1YnBhcnRzIChmaWxlcyBpbiBzLyBkaXJlY3RvcnkpXHJcbiAgICAgICAgaWYgKGhhc1N1YmRpcikge1xyXG4gICAgICAgICAgbm9ybWFsaXplZCA9IGAvbGRyYXcvcGFydHMvcy8ke2ZpbGVuYW1lfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBwcmltaXRpdmUgKHVzdWFsbHkgc3RhcnQgd2l0aCBudW1iZXJzIG9yIHNwZWNpZmljIHBhdHRlcm5zKVxyXG4gICAgICAgIGVsc2UgaWYgKGZpbGVuYW1lLm1hdGNoKC9eXFxkLykgfHwgZmlsZW5hbWUuc3RhcnRzV2l0aCgnc3R1ZCcpIHx8IGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2VkZ2UnKSkge1xyXG4gICAgICAgICAgbm9ybWFsaXplZCA9IGAvbGRyYXcvcC8ke2ZpbGVuYW1lfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERlZmF1bHQgdG8gcGFydHMgZGlyZWN0b3J5IGZvciBvdGhlciAuZGF0IGZpbGVzXHJcbiAgICAgICAgZWxzZSBpZiAoZmlsZW5hbWUuZW5kc1dpdGgoJy5kYXQnKSkge1xyXG4gICAgICAgICAgbm9ybWFsaXplZCA9IGAvbGRyYXcvcGFydHMvJHtmaWxlbmFtZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3IgTERSIGZpbGVzLCB1c2Ugb3V0cHV0IGRpcmVjdG9yeVxyXG4gICAgICAgIGVsc2UgaWYgKGZpbGVuYW1lLmVuZHNXaXRoKCcubGRyJykgfHwgZmlsZW5hbWUuZW5kc1dpdGgoJy5tcGQnKSkge1xyXG4gICAgICAgICAgbm9ybWFsaXplZCA9IGAvb3V0cHV0LyR7ZmlsZW5hbWV9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NvbnN0cnVjdGVkIFVSTDonLCBub3JtYWxpemVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsb2FkaW5nTWFuYWdlclJlZi5jdXJyZW50ID0gbWFuYWdlcjtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBtYW5hZ2VyLnNldFVSTE1vZGlmaWVyKHVuZGVmaW5lZCk7XHJcbiAgICAgIGxvYWRpbmdNYW5hZ2VyUmVmLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50IHx8IGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcblxyXG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCB3aWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcclxuICAgIGNvbnN0IGhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuICAgIHNjZW5lLmJhY2tncm91bmQgPSBuZXcgVEhSRUUuQ29sb3IoMHhlZWVlZWUpO1xyXG4gICAgc2NlbmVSZWYuY3VycmVudCA9IHNjZW5lO1xyXG5cclxuICAgIC8vIENhbWVyYSB3aXRoIHNldHRpbmdzIG9wdGltaXplZCBmb3IgbGFyZ2UgTEVHTyBtb2RlbHNcclxuICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgd2lkdGggLyBoZWlnaHQsIDAuMSwgMTAwMDAwKTtcclxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMzAwLCA0MDAsIDcwMCk7XHJcbiAgICBjYW1lcmFSZWYuY3VycmVudCA9IGNhbWVyYTtcclxuXHJcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlIH0pO1xyXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG4gICAgcmVuZGVyZXJSZWYuY3VycmVudCA9IHJlbmRlcmVyO1xyXG5cclxuICAgIGNvbnN0IGNvbnRyb2xzID0gbmV3IE9yYml0Q29udHJvbHMoY2FtZXJhLCByZW5kZXJlci5kb21FbGVtZW50KTtcclxuICAgIGNvbnRyb2xzLmVuYWJsZURhbXBpbmcgPSB0cnVlO1xyXG4gICAgY29udHJvbHMuZGFtcGluZ0ZhY3RvciA9IDAuMDU7XHJcbiAgICBjb250cm9scy5lbmFibGVQYW4gPSB0cnVlO1xyXG4gICAgY29udHJvbHMuZW5hYmxlUm90YXRlID0gdHJ1ZTtcclxuICAgIGNvbnRyb2xzLmVuYWJsZVpvb20gPSB0cnVlO1xyXG4gICAgY29udHJvbHMuc2NyZWVuU3BhY2VQYW5uaW5nID0gZmFsc2U7XHJcbiAgICBjb250cm9scy5taW5EaXN0YW5jZSA9IDEwO1xyXG4gICAgY29udHJvbHMubWF4RGlzdGFuY2UgPSA1MDAwMDsgIC8vIEdyZWF0bHkgaW5jcmVhc2VkIG1heCB6b29tIG91dCBkaXN0YW5jZVxyXG4gICAgY29udHJvbHMudGFyZ2V0LnNldCgwLCAwLCAwKTtcclxuICAgIGNvbnRyb2xzUmVmLmN1cnJlbnQgPSBjb250cm9scztcclxuXHJcbiAgICAvLyBFbmhhbmNlZCBsaWdodGluZyBmb3IgYmV0dGVyIHZpc2liaWxpdHlcclxuICAgIHNjZW5lLmFkZChuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4ZmZmZmZmLCAwLjkpKTsgLy8gQnJpZ2h0ZXIgYW1iaWVudCBsaWdodFxyXG5cclxuICAgIC8vIE1haW4gZGlyZWN0aW9uYWwgbGlnaHRcclxuICAgIGNvbnN0IGRpckxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDEuMCk7XHJcbiAgICBkaXJMaWdodC5wb3NpdGlvbi5zZXQoNTAwLCAxMDAwLCA1MDApO1xyXG4gICAgZGlyTGlnaHQuY2FzdFNoYWRvdyA9IGZhbHNlO1xyXG4gICAgc2NlbmUuYWRkKGRpckxpZ2h0KTtcclxuXHJcbiAgICAvLyBBZGRpdGlvbmFsIGZpbGwgbGlnaHRzIGZyb20gZGlmZmVyZW50IGFuZ2xlc1xyXG4gICAgY29uc3QgZmlsbExpZ2h0MSA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjUpO1xyXG4gICAgZmlsbExpZ2h0MS5wb3NpdGlvbi5zZXQoLTUwMCwgNTAwLCAtNTAwKTtcclxuICAgIHNjZW5lLmFkZChmaWxsTGlnaHQxKTtcclxuXHJcbiAgICBjb25zdCBmaWxsTGlnaHQyID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDAuNSk7XHJcbiAgICBmaWxsTGlnaHQyLnBvc2l0aW9uLnNldCg1MDAsIDUwMCwgLTUwMCk7XHJcbiAgICBzY2VuZS5hZGQoZmlsbExpZ2h0Mik7XHJcblxyXG4gICAgLy8gQWRkIGEgaGVtaXNwaGVyZSBsaWdodCBmb3IgbW9yZSBuYXR1cmFsIGxpZ2h0aW5nXHJcbiAgICBjb25zdCBoZW1pTGlnaHQgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KDB4ZmZmZmZmLCAweGNjY2NjYywgMC40KTtcclxuICAgIGhlbWlMaWdodC5wb3NpdGlvbi5zZXQoMCwgNTAwLCAwKTtcclxuICAgIHNjZW5lLmFkZChoZW1pTGlnaHQpO1xyXG5cclxuICAgIC8vIEdyaWQgaGVscGVyIHJlbW92ZWRcclxuICAgIC8vIGNvbnN0IGdyaWRIZWxwZXIgPSBuZXcgVEhSRUUuR3JpZEhlbHBlcigxMDAwLCAyMCk7XHJcbiAgICAvLyBzY2VuZS5hZGQoZ3JpZEhlbHBlcik7XHJcblxyXG4gICAgLy8gQWRkIGF4ZXMgaGVscGVyXHJcbiAgICBjb25zdCBheGVzSGVscGVyID0gbmV3IFRIUkVFLkF4ZXNIZWxwZXIoNTAwKTtcclxuICAgIHNjZW5lLmFkZChheGVzSGVscGVyKTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50IHx8ICFyZW5kZXJlclJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHcgPSBjb250YWluZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgY29uc3QgaCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgcmVuZGVyZXJSZWYuY3VycmVudC5zZXRTaXplKHcsIGgpO1xyXG4gICAgICBjYW1lcmFSZWYuY3VycmVudC5hc3BlY3QgPSB3IC8gaDtcclxuICAgICAgY2FtZXJhUmVmLmN1cnJlbnQudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcclxuXHJcbiAgICAvLyBBbmltYXRpb24gbG9vcCBpcyBub3cgaGFuZGxlZCBpbiB0aGUgY3ViZSBlZmZlY3RcclxuICAgIGNvbnNvbGUubG9nKCdTY2VuZSBpbml0aWFsaXplZCcpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICAvLyBLZWVwIHJlbmRlcmVyIGludGFjdCBidXQgY2xlYW4gdXAgZXZlbnQgbGlzdGVuZXJcclxuICAgICAgLy8gaWYgKHJlbmRlcmVyUmVmLmN1cnJlbnQgJiYgY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgLy8gICBjb250YWluZXJSZWYuY3VycmVudC5yZW1vdmVDaGlsZChyZW5kZXJlclJlZi5jdXJyZW50LmRvbUVsZW1lbnQpO1xyXG4gICAgICAvLyAgIHJlbmRlcmVyUmVmLmN1cnJlbnQuZGlzcG9zZSgpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcblxyXG4gIC8vIEFuaW1hdGlvbiBsb29wIC0gdXNpbmcgdXNlUmVmIHRvIGVuc3VyZSBzaW5nbGUgaW5zdGFuY2VcclxuICBjb25zdCBhbmltYXRpb25JZFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBpc0FuaW1hdGluZ1JlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXNjZW5lUmVmLmN1cnJlbnQgfHwgIXJlbmRlcmVyUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50IHx8ICFjb250cm9sc1JlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgLy8gUHJldmVudCBtdWx0aXBsZSBhbmltYXRpb24gbG9vcHNcclxuICAgIGlmIChpc0FuaW1hdGluZ1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdBbmltYXRpb24gYWxyZWFkeSBydW5uaW5nLCBza2lwcGluZy4uLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tbWVudGVkIG91dCBjYW5jZWxsYXRpb25cclxuICAgIC8vIGlmIChhbmltYXRpb25JZFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAvLyAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkUmVmLmN1cnJlbnQpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGlzQW5pbWF0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghaXNBbmltYXRpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgYWxsIHJlZnMgYmVmb3JlIHNjaGVkdWxpbmcgbmV4dCBmcmFtZVxyXG4gICAgICBpZiAoIWNvbnRyb2xzUmVmLmN1cnJlbnQgfHwgIXJlbmRlcmVyUmVmLmN1cnJlbnQgfHwgIXNjZW5lUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdBbmltYXRpb24gbG9vcCBzdG9wcGVkOiBtaXNzaW5nIHJlZnMnKTtcclxuICAgICAgICBpc0FuaW1hdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhbmltYXRpb25JZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBPbmx5IHZhbGlkYXRlIHNjZW5lIGlmIHdlJ3ZlIGhhZCByZWNlbnQgZXJyb3JzXHJcbiAgICAgICAgaWYgKGVycm9yQ291bnRSZWYuY3VycmVudCA+IDAgJiYgZXJyb3JDb3VudFJlZi5jdXJyZW50IDwgNSkge1xyXG4gICAgICAgICAgbGV0IGhhc051bGxDaGlsZHJlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgbGV0IG51bGxDaGVja0NvdW50ID0gMDtcclxuICAgICAgICAgIHNjZW5lUmVmLmN1cnJlbnQudHJhdmVyc2UoKGNoaWxkOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgbnVsbENoZWNrQ291bnQrKztcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9iamVjdCBpdHNlbGYgaGFzIHJlcXVpcmVkIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgaWYgKCFjaGlsZC5oYXNPd25Qcm9wZXJ0eSgndmlzaWJsZScpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignT2JqZWN0IG1pc3NpbmcgdmlzaWJsZSBwcm9wZXJ0eTonLCBjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbltpXSA9PT0gbnVsbCB8fCBjaGlsZC5jaGlsZHJlbltpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvdW5kIG51bGwvdW5kZWZpbmVkIGNoaWxkIGluIHNjZW5lIGF0IGluZGV4JywgaSwgJ29mIHBhcmVudDonLCBjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgIGhhc051bGxDaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbnVsbCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICBjaGlsZC5jaGlsZHJlbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgIGktLTsgLy8gQWRqdXN0IGluZGV4IGFmdGVyIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChoYXNOdWxsQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDbGVhbmVkIG51bGwgY2hpbGRyZW4gZnJvbSBzY2VuZSBncmFwaCBhZnRlciBjaGVja2luZycsIG51bGxDaGVja0NvdW50LCAnb2JqZWN0cycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRyb2xzIGFuZCByZW5kZXJcclxuICAgICAgICAvLyBWYWxpZGF0ZSBjb250cm9scyBzdGF0ZSBiZWZvcmUgdXBkYXRpbmdcclxuICAgICAgICBpZiAoY29udHJvbHNSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgY29udHJvbHMgdGFyZ2V0IGlzIHZhbGlkXHJcbiAgICAgICAgICBpZiAoIWlzRmluaXRlKGNvbnRyb2xzUmVmLmN1cnJlbnQudGFyZ2V0LngpIHx8XHJcbiAgICAgICAgICAgICAgIWlzRmluaXRlKGNvbnRyb2xzUmVmLmN1cnJlbnQudGFyZ2V0LnkpIHx8XHJcbiAgICAgICAgICAgICAgIWlzRmluaXRlKGNvbnRyb2xzUmVmLmN1cnJlbnQudGFyZ2V0LnopKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9scyB0YXJnZXQgYmVjYW1lIGludmFsaWQsIHJlc2V0dGluZyB0byBvcmlnaW4nKTtcclxuICAgICAgICAgICAgY29udHJvbHNSZWYuY3VycmVudC50YXJnZXQuc2V0KDAsIDAsIDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnRyb2xzUmVmLmN1cnJlbnQudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbGVhbiB1cCBhbnkgbnVsbCBvYmplY3RzIGluIHRoZSBzY2VuZSBiZWZvcmUgcmVuZGVyaW5nXHJcbiAgICAgICAgY29uc3QgY2xlYW51cE51bGxPYmplY3RzID0gKG9iajogVEhSRUUuT2JqZWN0M0QpID0+IHtcclxuICAgICAgICAgIGlmICghb2JqIHx8ICFvYmouY2hpbGRyZW4pIHJldHVybjtcclxuXHJcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IG51bGwvdW5kZWZpbmVkIGNoaWxkcmVuXHJcbiAgICAgICAgICBjb25zdCB2YWxpZENoaWxkcmVuID0gW107XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsICYmIGNoaWxkICE9PSB1bmRlZmluZWQgJiYgY2hpbGQudmlzaWJsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICBjbGVhbnVwTnVsbE9iamVjdHMoY2hpbGQpOyAvLyBSZWN1cnNpdmVseSBjbGVhbiBjaGlsZHJlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmdcclxuICAgICAgICAgIGlmICh2YWxpZENoaWxkcmVuLmxlbmd0aCAhPT0gb2JqLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBvYmouY2hpbGRyZW4gPSB2YWxpZENoaWxkcmVuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChzY2VuZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBjbGVhbnVwTnVsbE9iamVjdHMoc2NlbmVSZWYuY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW5kZXJlclJlZi5jdXJyZW50LnJlbmRlcihzY2VuZVJlZi5jdXJyZW50LCBjYW1lcmFSZWYuY3VycmVudCk7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCByZW5kZXJcclxuICAgICAgICBpZiAoZXJyb3JDb3VudFJlZi5jdXJyZW50ID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlbmRlcmluZyByZWNvdmVyZWQgYWZ0ZXInLCBlcnJvckNvdW50UmVmLmN1cnJlbnQsICdlcnJvcnMnKTtcclxuICAgICAgICAgIGVycm9yQ291bnRSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGVycm9yQ291bnRSZWYuY3VycmVudCA9IChlcnJvckNvdW50UmVmLmN1cnJlbnQgfHwgMCkgKyAxO1xyXG5cclxuICAgICAgICBpZiAoZXJyb3JDb3VudFJlZi5jdXJyZW50ID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBPbmx5IGxvZyBkZXRhaWxlZCBpbmZvIG9uIGZpcnN0IGVycm9yXHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGaXJzdCBlcnJvciBpbiBhbmltYXRpb24gbG9vcDonLCBlcnJvcik7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTY2VuZSBjaGlsZHJlbiBjb3VudDonLCBzY2VuZVJlZi5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTY2VuZSBzdGF0ZTonLCBzY2VuZVJlZi5jdXJyZW50KTtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbWVyYSBzdGF0ZTonLCBjYW1lcmFSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDb250cm9scyBzdGF0ZTonLCBjb250cm9sc1JlZi5jdXJyZW50KTtcclxuXHJcbiAgICAgICAgICAvLyBMb2cgdGhlIG1vZGVsIGdyb3VwIHN0YXRlXHJcbiAgICAgICAgICBpZiAobW9kZWxHcm91cFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vZGVsIGdyb3VwIHN0YXRlOicsIG1vZGVsR3JvdXBSZWYuY3VycmVudCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vZGVsIHZpc2libGU6JywgbW9kZWxHcm91cFJlZi5jdXJyZW50LnZpc2libGUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNb2RlbCBjaGlsZHJlbiBjb3VudDonLCBtb2RlbEdyb3VwUmVmLmN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0b3AgYW5pbWF0aW9uIGFmdGVyIHRvbyBtYW55IGVycm9yc1xyXG4gICAgICAgIGlmIChlcnJvckNvdW50UmVmLmN1cnJlbnQgPiAxMDApIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RvbyBtYW55IHJlbmRlciBlcnJvcnMsIHN0b3BwaW5nIGFuaW1hdGlvbiBsb29wJyk7XHJcbiAgICAgICAgICBpc0FuaW1hdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0YXJ0IHRoZSBhbmltYXRpb24gbG9vcFxyXG4gICAgYW5pbWF0ZSgpO1xyXG4gICAgY29uc29sZS5sb2coJ0FuaW1hdGlvbiBsb29wIHN0YXJ0ZWQnKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAvLyBQcm9wZXJseSBjbGVhbiB1cCBhbmltYXRpb24gbG9vcFxyXG4gICAgICBpc0FuaW1hdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGlmIChhbmltYXRpb25JZFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWRSZWYuY3VycmVudCk7XHJcbiAgICAgICAgYW5pbWF0aW9uSWRSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICAvLyBUZXN0IGN1YmUgY29tbWVudGVkIG91dCAtIExFR08gbW9kZWwgc2hvdWxkIGxvYWQgaW5zdGVhZFxyXG4gIC8qXHJcbiAgY29uc3QgY3ViZVJlZiA9IHVzZVJlZjxUSFJFRS5NZXNoIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXNjZW5lUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAvLyBQcmV2ZW50IGFkZGluZyBjdWJlIG11bHRpcGxlIHRpbWVzXHJcbiAgICBpZiAoY3ViZVJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgLy8gQWRkIGEgc2ltcGxlIHJlZCBjdWJlIHRoYXQgd2Uga25vdyB3b3Jrc1xyXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMzAsIDMwLCAzMCk7XHJcbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XHJcbiAgICAgIGNvbG9yOiAweGZmMDAwMCxcclxuICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjdWJlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcclxuICAgIGN1YmUucG9zaXRpb24uc2V0KDAsIDMwMCwgMCk7XHJcblxyXG4gICAgc2NlbmVSZWYuY3VycmVudC5hZGQoY3ViZSk7XHJcblxyXG4gICAgY3ViZVJlZi5jdXJyZW50ID0gY3ViZTtcclxuICAgIGNvbnNvbGUubG9nKCdTaW1wbGUgdGVzdCBjdWJlIGFkZGVkIGF0OicsIGN1YmUucG9zaXRpb24pO1xyXG4gICAgY29uc29sZS5sb2coJ1NjZW5lIG5vdyBoYXMnLCBzY2VuZVJlZi5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aCwgJ2NoaWxkcmVuJyk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgLy8gQ29tbWVudGVkIG91dCBjbGVhbnVwIHRvIGtlZXAgdGhlIGN1YmUgdmlzaWJsZVxyXG4gICAgICAvLyBpZiAoc2NlbmVSZWYuY3VycmVudCAmJiBjdWJlKSB7XHJcbiAgICAgIC8vICAgc2NlbmVSZWYuY3VycmVudC5yZW1vdmUoY3ViZSk7ICAvLyBBbHNvIG5lZWQgdG8gcHJldmVudCByZW1vdmFsIGZyb20gc2NlbmVcclxuICAgICAgLy8gICBnZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICAgIC8vICAgbWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGN1YmVSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuICAqL1xyXG5cclxuICAvLyBDdWJlIGFuaW1hdGlvbiBjb21tZW50ZWQgb3V0IHNpbmNlIGN1YmUgaXMgcmVtb3ZlZFxyXG4gIC8qXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XHJcbiAgICAgIGlmIChjdWJlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjdWJlUmVmLmN1cnJlbnQucm90YXRpb24ueCArPSAwLjAxO1xyXG4gICAgICAgIGN1YmVSZWYuY3VycmVudC5yb3RhdGlvbi55ICs9IDAuMDE7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaWQgPSBzZXRJbnRlcnZhbChhbmltYXRlLCAxNik7IC8vIH42MGZwc1xyXG5cclxuICAgIC8vIENvbW1lbnRlZCBvdXQgaW50ZXJ2YWwgY2xlYW51cFxyXG4gICAgLy8gcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaWQpO1xyXG4gICAgcmV0dXJuICgpID0+IHt9O1xyXG4gIH0sIFtdKTtcclxuICAqL1xyXG5cclxuICAvLyBMRUdPIExPQURJTkcgQ09ERVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAvLyBOZWVkIGVpdGhlciBtb2RlbFBhdGggb3IgbGRyYXdDb250ZW50XHJcbiAgICBpZiAoKCFtb2RlbFBhdGggJiYgIWxkcmF3Q29udGVudCkgfHwgIXNjZW5lUmVmLmN1cnJlbnQgfHwgIXJlbmRlcmVyUmVmLmN1cnJlbnQgfHwgIWNhbWVyYVJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgLy8gU2tpcCBpZiB3ZSdyZSBhbHJlYWR5IGxvYWRpbmcgdGhpcyBleGFjdCBtb2RlbFxyXG4gICAgY29uc3QgY3VycmVudElkZW50aWZpZXIgPSBsZHJhd0NvbnRlbnQgPyBgY29udGVudC0ke2xkcmF3Q29udGVudC5zdWJzdHJpbmcoMCwgMTAwKX1gIDogbW9kZWxQYXRoO1xyXG4gICAgaWYgKGN1cnJlbnRNb2RlbFBhdGhSZWYuY3VycmVudCA9PT0gY3VycmVudElkZW50aWZpZXIgJiYgaXNMb2FkaW5nUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1NhbWUgbW9kZWwgYWxyZWFkeSBsb2FkaW5nLCBza2lwcGluZy4uLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2tpcCBpZiB0aGlzIG1vZGVsIGlzIGFscmVhZHkgbG9hZGVkXHJcbiAgICBpZiAoY3VycmVudE1vZGVsUGF0aFJlZi5jdXJyZW50ID09PSBjdXJyZW50SWRlbnRpZmllciAmJiBtb2RlbEdyb3VwUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ01vZGVsIGFscmVhZHkgbG9hZGVkLCBza2lwcGluZy4uLicpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJldmVudCBjb25jdXJyZW50IGxvYWRzXHJcbiAgICBpZiAoaXNMb2FkaW5nUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coJ0Fub3RoZXIgbW9kZWwgaXMgbG9hZGluZywgc2tpcHBpbmcuLi4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNhdmUgY2FtZXJhIHN0YXRlIGJlZm9yZSByZW1vdmluZyBtb2RlbCBpZiBwcmVzZXJ2ZUNhbWVyYSBpcyB0cnVlXHJcbiAgICBpZiAocHJlc2VydmVDYW1lcmEgJiYgY2FtZXJhUmVmLmN1cnJlbnQgJiYgY29udHJvbHNSZWYuY3VycmVudCkge1xyXG4gICAgICBzYXZlZENhbWVyYVBvc2l0aW9uLmN1cnJlbnQgPSBjYW1lcmFSZWYuY3VycmVudC5wb3NpdGlvbi5jbG9uZSgpO1xyXG4gICAgICBzYXZlZENhbWVyYVRhcmdldC5jdXJyZW50ID0gY29udHJvbHNSZWYuY3VycmVudC50YXJnZXQuY2xvbmUoKTtcclxuICAgICAgY29uc29sZS5sb2coJ1NhdmVkIGNhbWVyYSBwb3NpdGlvbjonLCBzYXZlZENhbWVyYVBvc2l0aW9uLmN1cnJlbnQpO1xyXG4gICAgICBjb25zb2xlLmxvZygnU2F2ZWQgY2FtZXJhIHRhcmdldDonLCBzYXZlZENhbWVyYVRhcmdldC5jdXJyZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDbGVhbiB1cCBwcmV2aW91cyBtb2RlbCBzYWZlbHlcclxuICAgIGlmIChtb2RlbEdyb3VwUmVmLmN1cnJlbnQgJiYgc2NlbmVSZWYuY3VycmVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZygnUmVtb3ZpbmcgcHJldmlvdXMgbW9kZWwgZnJvbSBzY2VuZScpO1xyXG4gICAgICAvLyBNYXJrIGFzIGludmlzaWJsZSBmaXJzdCB0byBwcmV2ZW50IHJlbmRlciBpc3N1ZXNcclxuICAgICAgbW9kZWxHcm91cFJlZi5jdXJyZW50LnZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBmcm9tIHNjZW5lIG9uIG5leHQgdGlja1xyXG4gICAgICBjb25zdCBtb2RlbFRvUmVtb3ZlID0gbW9kZWxHcm91cFJlZi5jdXJyZW50O1xyXG4gICAgICBtb2RlbEdyb3VwUmVmLmN1cnJlbnQgPSBudWxsO1xyXG5cclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHNjZW5lUmVmLmN1cnJlbnQgJiYgbW9kZWxUb1JlbW92ZSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0FjdHVhbGx5IHJlbW92aW5nIG1vZGVsIGFuZCBkaXNwb3NpbmcgcmVzb3VyY2VzJyk7XHJcbiAgICAgICAgICBzY2VuZVJlZi5jdXJyZW50LnJlbW92ZShtb2RlbFRvUmVtb3ZlKTtcclxuICAgICAgICAgIC8vIERpc3Bvc2Ugb2YgZ2VvbWV0cmllcyBhbmQgbWF0ZXJpYWxzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgbW9kZWxUb1JlbW92ZS50cmF2ZXJzZSgoY2hpbGQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuZ2VvbWV0cnkpIGNoaWxkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQubWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5mb3JFYWNoKChtYXQ6IGFueSkgPT4gbWF0LmRpc3Bvc2UoKSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ01vZGVsIHJlbW92YWwgY29tcGxldGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgbG9hZHMgb2YgdGhlIHNhbWUgbW9kZWxcclxuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgIGlzTG9hZGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIGN1cnJlbnRNb2RlbFBhdGhSZWYuY3VycmVudCA9IGN1cnJlbnRJZGVudGlmaWVyIHx8ICdnZW5lcmF0ZWQnO1xyXG5cclxuICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBlcnJvclxyXG4gICAgc2V0TG9hZEVycm9yKG51bGwpO1xyXG5cclxuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBMRHJhd0xvYWRlcihsb2FkaW5nTWFuYWdlclJlZi5jdXJyZW50ID8/IHVuZGVmaW5lZCk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBwYXJ0cyBsaWJyYXJ5IHBhdGggdG8gdGhlIGxkcmF3IGRpcmVjdG9yeVxyXG4gICAgbG9hZGVyLnNldFBhcnRzTGlicmFyeVBhdGgoJy9sZHJhdy8nKTtcclxuXHJcbiAgICAvLyBFbmFibGUgc21vb3RoIG5vcm1hbHMgZm9yIGJldHRlciByZW5kZXJpbmdcclxuICAgIGxvYWRlci5zbW9vdGhOb3JtYWxzID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBTZXQgdGhlIGZpbGUgbWFwIGZvciBiZXR0ZXIgcGFydCByZXNvbHV0aW9uXHJcbiAgICBsb2FkZXIuc2V0RmlsZU1hcCh7fSk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBjb25kaXRpb25hbCBsaW5lIG1hdGVyaWFsIGNsYXNzIChub3QgYW4gaW5zdGFuY2UpXHJcbiAgICBsb2FkZXIuc2V0Q29uZGl0aW9uYWxMaW5lTWF0ZXJpYWwoTERyYXdDb25kaXRpb25hbExpbmVNYXRlcmlhbCk7XHJcblxyXG4gICAgY29uc29sZS5sb2cobGRyYXdDb250ZW50ID8gJ0xvYWRpbmcgTERyYXcgZnJvbSBjb250ZW50JyA6IGBMb2FkaW5nIExEUiBmaWxlOiAke21vZGVsUGF0aH1gKTtcclxuXHJcbiAgICAvLyBUcnkgdG8gcHJlbG9hZCBtYXRlcmlhbHMgZmlyc3QsIGJ1dCBkb24ndCBmYWlsIGlmIGl0IGRvZXNuJ3Qgd29ya1xyXG4gICAgY29uc3QgbWF0ZXJpYWxzUHJvbWlzZSA9IGxvYWRlci5wcmVsb2FkTWF0ZXJpYWxzKCcvbGRyYXcvTERDb25maWcubGRyJylcclxuICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXRlcmlhbHMgcHJlbG9hZGVkIHN1Y2Nlc3NmdWxseScpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHByZWxvYWQgbWF0ZXJpYWxzLCB1c2luZyBkZWZhdWx0czonLCBlcnIubWVzc2FnZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIE92ZXJyaWRlIGNvbnNvbGUud2FybiB0byBjYXRjaCBzdWJvYmplY3QgbG9hZGluZyBlcnJvcnNcclxuICAgIGNvbnN0IG9yaWdpbmFsV2FybiA9IGNvbnNvbGUud2FybjtcclxuICAgIGxldCBoYXNTdWJvYmplY3RFcnJvciA9IGZhbHNlO1xyXG4gICAgY29uc29sZS53YXJuID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3Muam9pbignICcpO1xyXG4gICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygnY291bGQgbm90IGJlIGxvYWRlZCcpIHx8IG1lc3NhZ2UuaW5jbHVkZXMoJ1N1Ym9iamVjdCcpKSB7XHJcbiAgICAgICAgaGFzU3Vib2JqZWN0RXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIC8vIERvbid0IGxvZyB0aGUgd2FybmluZyB0byBjb25zb2xlXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIG9yaWdpbmFsV2Fybi5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTG9hZCB0aGUgbW9kZWwgKHdhaXQgZm9yIG1hdGVyaWFscyBpZiBwb3NzaWJsZSwgYnV0IGRvbid0IGJsb2NrKVxyXG4gICAgbWF0ZXJpYWxzUHJvbWlzZVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGRpcmVjdCBjb250ZW50LCBwYXJzZSBpdDsgb3RoZXJ3aXNlIGxvYWQgZnJvbSBmaWxlXHJcbiAgICAgICAgbGV0IG1vZGVsUHJvbWlzZTogUHJvbWlzZTxUSFJFRS5Hcm91cCB8IG51bGw+O1xyXG5cclxuICAgICAgICBpZiAobGRyYXdDb250ZW50KSB7XHJcbiAgICAgICAgICAvLyBVc2UgcGFyc2Ugd2l0aCBjYWxsYmFja3MgYW5kIHdyYXAgaW4gYSBwcm9taXNlXHJcbiAgICAgICAgICBtb2RlbFByb21pc2UgPSBuZXcgUHJvbWlzZTxUSFJFRS5Hcm91cCB8IG51bGw+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIGxvYWRlci5wYXJzZShcclxuICAgICAgICAgICAgICBsZHJhd0NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgKGdyb3VwOiBUSFJFRS5Hcm91cCkgPT4gcmVzb2x2ZShncm91cCksXHJcbiAgICAgICAgICAgICAgKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgTERyYXcgY29udGVudDonLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxQYXRoKSB7XHJcbiAgICAgICAgICBtb2RlbFByb21pc2UgPSBsb2FkZXIubG9hZEFzeW5jKG1vZGVsUGF0aCkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbW9kZWw6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtb2RlbFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb2RlbFByb21pc2UudGhlbigoZ3JvdXApID0+IHtcclxuICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29uc29sZS53YXJuXHJcbiAgICAgICAgICBjb25zb2xlLndhcm4gPSBvcmlnaW5hbFdhcm47XHJcblxyXG4gICAgICAgICAgaWYgKCFncm91cCB8fCBjYW5jZWxsZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSB3ZXJlIHN1Ym9iamVjdCBlcnJvcnNcclxuICAgICAgICAgIGlmIChoYXNTdWJvYmplY3RFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTW9kZWwgaGFzIG1pc3NpbmcgcGFydHMsIGRpc3BsYXlpbmcgYXMgZXJyb3InKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBhcnRzIC0gbW9kZWwgY2Fubm90IGJlIHJlbmRlcmVkIHByb3Blcmx5Jyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ01vZGVsIGxvYWRlZCBzdWNjZXNzZnVsbHk6JywgZ3JvdXApO1xyXG4gICAgICAgICAgaXNMb2FkaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBTYWZlIHRyYXZlcnNhbCB0byBoYW5kbGUgbnVsbCBvYmplY3RzIC0gcmVtb3ZlIHRoZW0gY29tcGxldGVseVxyXG4gICAgICAgICAgY29uc3Qgc2FmZVRyYXZlcnNlID0gKG9iajogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFNraXAgaWYgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFvYmopIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIFNraXAgaWYgbm90IGEgdmFsaWQgb2JqZWN0XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gU2tpcCBpZiBkb2Vzbid0IGhhdmUgdmlzaWJsZSBwcm9wZXJ0eSAobm90IGEgVGhyZWUuanMgb2JqZWN0KVxyXG4gICAgICAgICAgICBpZiAoISgndmlzaWJsZScgaW4gb2JqKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG9iamVjdFxyXG4gICAgICAgICAgICBpZiAoKG9iaiBhcyBhbnkpLmlzTWVzaCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBvYmogYXMgVEhSRUUuTWVzaDtcclxuICAgICAgICAgICAgICBpZiAoIW1lc2gubWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGRlZmF1bHQgbWF0ZXJpYWwgaWYgbWlzc2luZ1xyXG4gICAgICAgICAgICAgICAgbWVzaC5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XHJcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAweDgwODA4MCxcclxuICAgICAgICAgICAgICAgICAgc2lkZTogVEhSRUUuRG91YmxlU2lkZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkZWQgZGVmYXVsdCBtYXRlcmlhbCB0byBtZXNoOicsIG1lc2gubmFtZSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1lc2gubWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhcnJheSBvZiBtYXRlcmlhbHNcclxuICAgICAgICAgICAgICAgIG1lc2gubWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsLm1hcCgobWF0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghbWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlcGxhY2luZyBudWxsIG1hdGVyaWFsIGluIGFycmF5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogMHg4MDgwODAsXHJcbiAgICAgICAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG51bGwgY2hpbGRyZW4gY29tcGxldGVseVxyXG4gICAgICAgICAgICBpZiAob2JqLmNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkob2JqLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZhbGlkQ2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG9iai5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBrZWVwIHZhbGlkIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiAndmlzaWJsZScgaW4gY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgdmFsaWRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgc2FmZVRyYXZlcnNlKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZW1vdmluZyBpbnZhbGlkIGNoaWxkIGZyb20gbW9kZWw6JywgY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAvLyBSZXBsYWNlIGNoaWxkcmVuIGFycmF5IHdpdGggb25seSB2YWxpZCBvbmVzXHJcbiAgICAgICAgICAgICAgb2JqLmNoaWxkcmVuID0gdmFsaWRDaGlsZHJlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBzYWZlVHJhdmVyc2UoZ3JvdXApO1xyXG5cclxuICAgICAgICAvLyBTa2lwIHN0ZXAgcGFyc2luZyBmb3Igbm93IC0ganVzdCBhZGQgdGhlIG1vZGVsIGFzLWlzXHJcbiAgICAgICAgLypcclxuICAgICAgICAvLyBQYXJzZSBTVEVQIGNvbW1hbmRzIGZyb20gdGhlIExEcmF3IGNvbnRlbnQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgbGV0IHN0ZXBCb3VuZGFyaWVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGlmIChjb250ZW50KSB7XHJcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgbGV0IHBhcnRDb3VudCA9IDA7XHJcbiAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XHJcbiAgICAgICAgICAgIGlmICh0cmltbWVkLnN0YXJ0c1dpdGgoJzEgJykpIHtcclxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcGFydCBsaW5lXHJcbiAgICAgICAgICAgICAgcGFydENvdW50Kys7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJpbW1lZCA9PT0gJzAgU1RFUCcgfHwgdHJpbW1lZC50b0xvd2VyQ2FzZSgpID09PSAnMCBzdGVwJykge1xyXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBTVEVQIGNvbW1hbmRcclxuICAgICAgICAgICAgICBzdGVwQm91bmRhcmllcy5wdXNoKHBhcnRDb3VudCk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIFNURVAgY29tbWFuZCBhZnRlciBwYXJ0ICR7cGFydENvdW50fWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGlmIChzdGVwQm91bmRhcmllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3N0ZXBCb3VuZGFyaWVzLmxlbmd0aH0gU1RFUCBjb21tYW5kcyBpbiBtb2RlbGApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3JnYW5pemUgbW9kZWwgaW50byBzdGVwcyBiYXNlZCBvbiBTVEVQIGNvbW1hbmRzXHJcbiAgICAgICAgY29uc3Qgc3RlcHM6IFRIUkVFLkdyb3VwW10gPSBbXTtcclxuICAgICAgICBjb25zdCBhbGxQYXJ0czogVEhSRUUuT2JqZWN0M0RbXSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBDb2xsZWN0IG9ubHkgZGlyZWN0IGNoaWxkIGdyb3Vwcy9vYmplY3RzIChub3QgbmVzdGVkIG1lc2hlcylcclxuICAgICAgICAvLyBFYWNoIGRpcmVjdCBjaGlsZCB0eXBpY2FsbHkgcmVwcmVzZW50cyBvbmUgcGFydCBmcm9tIHRoZSBMRHJhdyBmaWxlXHJcbiAgICAgICAgY29uc3QgY29sbGVjdFRvcExldmVsUGFydHMgPSAob2JqOiBhbnksIGRlcHRoOiBudW1iZXIgPSAwKSA9PiB7XHJcbiAgICAgICAgICAvLyBGb3IgdGhlIHJvb3QgZ3JvdXAsIHByb2Nlc3MgaXRzIGRpcmVjdCBjaGlsZHJlblxyXG4gICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIG9iai5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgLy8gRWFjaCBkaXJlY3QgY2hpbGQgaXMgdHlwaWNhbGx5IGEgcGFydFxyXG4gICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnR3JvdXAnIHx8IGNoaWxkLnR5cGUgPT09ICdPYmplY3QzRCcgfHwgY2hpbGQuaXNNZXNoIHx8IGNoaWxkLmlzTGluZSkge1xyXG4gICAgICAgICAgICAgICAgYWxsUGFydHMucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb2xsZWN0VG9wTGV2ZWxQYXJ0cyhncm91cCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7YWxsUGFydHMubGVuZ3RofSB0b3AtbGV2ZWwgcGFydHMgaW4gbW9kZWxgKTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBTVEVQIGNvbW1hbmRzLCBvcmdhbml6ZSBwYXJ0cyBhY2NvcmRpbmdseVxyXG4gICAgICAgIGlmIChzdGVwQm91bmRhcmllcy5sZW5ndGggPiAwICYmIGFsbFBhcnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IHRvdGFsU3RlcHMgPSBzdGVwQm91bmRhcmllcy5sZW5ndGg7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgT3JnYW5pemluZyAke2FsbFBhcnRzLmxlbmd0aH0gcGFydHMgaW50byAke3RvdGFsU3RlcHN9IHN0ZXBzYCk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCBib3VuZGFyaWVzIChjdW11bGF0aXZlIHBhcnQgY291bnRzKTogJHtzdGVwQm91bmRhcmllcy5qb2luKCcsICcpfWApO1xyXG5cclxuICAgICAgICAgIC8vIEFzc2lnbiBzdGVwIG51bWJlcnMgdG8gZWFjaCBwYXJ0XHJcbiAgICAgICAgICBhbGxQYXJ0cy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBGaW5kIHdoaWNoIHN0ZXAgdGhpcyBwYXJ0IGJlbG9uZ3MgdG9cclxuICAgICAgICAgICAgbGV0IHN0ZXBOdW1iZXIgPSAxO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGluZGV4IDwgc3RlcEJvdW5kYXJpZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHN0ZXBOdW1iZXIgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXNzaWduIHN0ZXAgbnVtYmVyIHRvIHRoaXMgcGFydCBhbmQgYWxsIGl0cyBjaGlsZHJlblxyXG4gICAgICAgICAgICBwYXJ0LnVzZXJEYXRhLnN0ZXBOdW1iZXIgPSBzdGVwTnVtYmVyO1xyXG4gICAgICAgICAgICBwYXJ0LnRyYXZlcnNlKChjaGlsZDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgY2hpbGQudXNlckRhdGEuc3RlcE51bWJlciA9IHN0ZXBOdW1iZXI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIHN0ZXAgZ3JvdXBzIGFuZCBhZGQgcGFydHMgdG8gdGhlbVxyXG4gICAgICAgICAgZm9yIChsZXQgc3RlcE51bSA9IDE7IHN0ZXBOdW0gPD0gdG90YWxTdGVwczsgc3RlcE51bSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xyXG4gICAgICAgICAgICBzdGVwR3JvdXAubmFtZSA9IGBTdGVwICR7c3RlcE51bX1gO1xyXG4gICAgICAgICAgICBsZXQgcGFydHNJblN0ZXAgPSAwO1xyXG5cclxuICAgICAgICAgICAgYWxsUGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcclxuICAgICAgICAgICAgICBpZiAocGFydC51c2VyRGF0YS5zdGVwTnVtYmVyID09PSBzdGVwTnVtKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwR3JvdXAuYWRkKHBhcnQpO1xyXG4gICAgICAgICAgICAgICAgcGFydHNJblN0ZXArKztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhcnRzSW5TdGVwID4gMCkge1xyXG4gICAgICAgICAgICAgIHN0ZXBzLnB1c2goc3RlcEdyb3VwKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3RlcCAke3N0ZXBOdW19OiAke3BhcnRzSW5TdGVwfSBwYXJ0c2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyBTVEVQIGNvbW1hbmRzIGZvdW5kLCB0cmVhdCBhbGwgcGFydHMgYXMgb25lIHN0ZXBcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBTVEVQIGNvbW1hbmRzIGZvdW5kLCB0cmVhdGluZyBtb2RlbCBhcyBzaW5nbGUgc3RlcCcpO1xyXG4gICAgICAgICAgY29uc3Qgc2luZ2xlU3RlcCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xyXG4gICAgICAgICAgc2luZ2xlU3RlcC5uYW1lID0gJ1N0ZXAgMSc7XHJcbiAgICAgICAgICBhbGxQYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xyXG4gICAgICAgICAgICBwYXJ0LnVzZXJEYXRhLnN0ZXBOdW1iZXIgPSAxO1xyXG4gICAgICAgICAgICBwYXJ0LnRyYXZlcnNlKChjaGlsZDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgY2hpbGQudXNlckRhdGEuc3RlcE51bWJlciA9IDE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzaW5nbGVTdGVwLmFkZChwYXJ0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKHNpbmdsZVN0ZXAuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBzdGVwcy5wdXNoKHNpbmdsZVN0ZXApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29sbGVjdCBhbGwgbWVzaC9saW5lIG9iamVjdHMgZm9yIHZpc2liaWxpdHkgY29udHJvbFxyXG4gICAgICAgIGNvbnN0IGFsbFJlbmRlcmFibGVzOiBUSFJFRS5PYmplY3QzRFtdID0gW107XHJcbiAgICAgICAgZ3JvdXAudHJhdmVyc2UoKGNoaWxkOiBhbnkpID0+IHtcclxuICAgICAgICAgIGlmIChjaGlsZC5pc01lc2ggfHwgY2hpbGQuaXNMaW5lIHx8IGNoaWxkLmlzTGluZVNlZ21lbnRzKSB7XHJcbiAgICAgICAgICAgIGFsbFJlbmRlcmFibGVzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgTW9kZWwgb3JnYW5pemVkIGludG8gJHtzdGVwcy5sZW5ndGh9IHN0ZXBzIHdpdGggJHthbGxSZW5kZXJhYmxlcy5sZW5ndGh9IHJlbmRlcmFibGUgb2JqZWN0c2ApO1xyXG4gICAgICAgIHN0ZXBzUmVmLmN1cnJlbnQgPSBzdGVwcztcclxuICAgICAgICBhbGxQYXJ0c1JlZi5jdXJyZW50ID0gYWxsUmVuZGVyYWJsZXM7XHJcbiAgICAgICAgc2V0VG90YWxTdGVwcyhzdGVwcy5sZW5ndGgpO1xyXG4gICAgICAgIHNldEN1cnJlbnRTdGVwKHN0ZXBzLmxlbmd0aCk7IC8vIFN0YXJ0IHdpdGggYWxsIHN0ZXBzIHZpc2libGVcclxuICAgICAgICAqL1xyXG5cclxuICAgICAgICAvLyBQb3NpdGlvbiBtb2RlbCBhdCBvcmlnaW5cclxuICAgICAgICBncm91cC5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XHJcbiAgICAgICAgZ3JvdXAucm90YXRpb24ueCA9IE1hdGguUEk7ICAvLyBSb3RhdGlvbiBjYW4gY2F1c2UgaXNzdWVzLCBrZWVwaW5nIGl0IGNvbW1lbnRlZFxyXG4gICAgICAgIG1vZGVsR3JvdXBSZWYuY3VycmVudCA9IGdyb3VwO1xyXG5cclxuICAgICAgICBpZiAoc2NlbmVSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc2NlbmVSZWYuY3VycmVudC5hZGQoZ3JvdXApO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ01vZGVsIGFkZGVkIHRvIHNjZW5lJyk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnR3JvdXAgY2hpbGRyZW46JywgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdHcm91cCB2aXNpYmxlOicsIGdyb3VwLnZpc2libGUpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0dyb3VwIGluIHNjZW5lOicsIHNjZW5lUmVmLmN1cnJlbnQuY2hpbGRyZW4uaW5jbHVkZXMoZ3JvdXApKTtcclxuXHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGdyb3VwIGlzIHZpc2libGVcclxuICAgICAgICAgIGdyb3VwLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgZ3JvdXAudHJhdmVyc2UoKGNoaWxkOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgY2hpbGQudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB2aXNpYmxlIG1lc2hlcyBhbmQgY2hlY2sgbWF0ZXJpYWxzXHJcbiAgICAgICAgICBsZXQgbWVzaENvdW50ID0gMDtcclxuICAgICAgICAgIGxldCB2aXNpYmxlQ291bnQgPSAwO1xyXG4gICAgICAgICAgZ3JvdXAudHJhdmVyc2UoKGNoaWxkOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKChjaGlsZCBhcyBhbnkpLmlzTWVzaCkge1xyXG4gICAgICAgICAgICAgIG1lc2hDb3VudCsrO1xyXG4gICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBjaGlsZCBhcyBUSFJFRS5NZXNoO1xyXG4gICAgICAgICAgICAgIGlmIChtZXNoLnZpc2libGUpIHZpc2libGVDb3VudCsrO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIW1lc2guZ2VvbWV0cnkuYm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBMb2cgbWVzaCBkZXRhaWxzXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ01lc2ggZGV0YWlsczonLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBtZXNoLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBtZXNoLnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbDogbWVzaC5tYXRlcmlhbCxcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5VmVydGljZXM6IG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbj8uY291bnQgfHwgMCxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBtZXNoLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IG1lc2guc2NhbGVcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG1lc2ggaGFzIGEgbWF0ZXJpYWxcclxuICAgICAgICAgICAgICBpZiAoIW1lc2gubWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWVzaCBoYXMgbm8gbWF0ZXJpYWwsIGFkZGluZyBkZWZhdWx0Jyk7XHJcbiAgICAgICAgICAgICAgICBtZXNoLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtcclxuICAgICAgICAgICAgICAgICAgY29sb3I6IDB4ZmYwMDAwLFxyXG4gICAgICAgICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7bWVzaENvdW50fSBtZXNoZXMsICR7dmlzaWJsZUNvdW50fSB2aXNpYmxlYCk7XHJcblxyXG4gICAgICAgICAgLy8gVGVzdCBjdWJlIHJlbW92ZWQgLSByZW5kZXJpbmcgdmVyaWZpZWQgdG8gYmUgd29ya2luZ1xyXG4gICAgICAgICAgLy8gY29uc3QgdGVzdEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDUwLCA1MCwgNTApO1xyXG4gICAgICAgICAgLy8gY29uc3QgdGVzdE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHsgY29sb3I6IDB4MDBmZjAwIH0pO1xyXG4gICAgICAgICAgLy8gY29uc3QgdGVzdEN1YmUgPSBuZXcgVEhSRUUuTWVzaCh0ZXN0R2VvbWV0cnksIHRlc3RNYXRlcmlhbCk7XHJcbiAgICAgICAgICAvLyB0ZXN0Q3ViZS5wb3NpdGlvbi5zZXQoMTAwLCAyNSwgMCk7XHJcbiAgICAgICAgICAvLyBzY2VuZVJlZi5jdXJyZW50LmFkZCh0ZXN0Q3ViZSk7XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVGVzdCBjdWJlIGFkZGVkIGF0OicsIHRlc3RDdWJlLnBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvcmNlIHVwZGF0ZSBtYXRyaWNlcyBiZWZvcmUgY2FsY3VsYXRpbmcgYm91bmRpbmcgYm94XHJcbiAgICAgICAgZ3JvdXAudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBib3VuZGluZyBib3ggYW5kIGNlbnRlciBjYW1lcmFcclxuICAgICAgICBjb25zdCBib3ggPSBuZXcgVEhSRUUuQm94MygpLnNldEZyb21PYmplY3QoZ3JvdXApO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJveC5nZXRDZW50ZXIobmV3IFRIUkVFLlZlY3RvcjMoKSk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJveC5nZXRTaXplKG5ldyBUSFJFRS5WZWN0b3IzKCkpO1xyXG5cclxuICAgICAgICAvLyBMb2cgbW9kZWwgaW5mb3JtYXRpb25cclxuICAgICAgICBpZiAoIWJveC5pc0VtcHR5KCkgJiYgc2l6ZS54ID4gMCAmJiBzaXplLnkgPiAwICYmIHNpemUueiA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2RlbCBjZW50ZXI6JywgY2VudGVyLngsIGNlbnRlci55LCBjZW50ZXIueik7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnTW9kZWwgc2l6ZTonLCBzaXplLngsIHNpemUueSwgc2l6ZS56KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdNb2RlbCBoYXMgZW1wdHkvaW52YWxpZCBib3VuZGluZyBib3gnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb250cm9sc1JlZi5jdXJyZW50ICYmIGNhbWVyYVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAvLyBSZXN0b3JlIGNhbWVyYSBwb3NpdGlvbiBpZiBwcmVzZXJ2ZUNhbWVyYSBpcyB0cnVlIGFuZCB3ZSBoYXZlIHNhdmVkIHN0YXRlXHJcbiAgICAgICAgICBpZiAocHJlc2VydmVDYW1lcmEgJiYgc2F2ZWRDYW1lcmFQb3NpdGlvbi5jdXJyZW50ICYmIHNhdmVkQ2FtZXJhVGFyZ2V0LmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc3RvcmluZyBjYW1lcmEgcG9zaXRpb24nKTtcclxuICAgICAgICAgICAgY2FtZXJhUmVmLmN1cnJlbnQucG9zaXRpb24uY29weShzYXZlZENhbWVyYVBvc2l0aW9uLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICBjb250cm9sc1JlZi5jdXJyZW50LnRhcmdldC5jb3B5KHNhdmVkQ2FtZXJhVGFyZ2V0LmN1cnJlbnQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSnVzdCB1cGRhdGUgY29udHJvbHMgdG8gbG9vayBhdCBvcmlnaW4gZm9yIGluaXRpYWwgbG9hZFxyXG4gICAgICAgICAgICBjb250cm9sc1JlZi5jdXJyZW50LnRhcmdldC5zZXQoMCwgMCwgMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250cm9sc1JlZi5jdXJyZW50LnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgaGFuZGxlIHJlbmRlcmluZ1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTY2VuZSBjaGlsZHJlbjonLCBzY2VuZVJlZi5jdXJyZW50Py5jaGlsZHJlbi5sZW5ndGggfHwgMCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbnNvbGUud2FybiBpbiBjYXNlIG9mIGVycm9yXHJcbiAgICAgICAgY29uc29sZS53YXJuID0gb3JpZ2luYWxXYXJuO1xyXG5cclxuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBtb2RlbDonLCBlcnJvcik7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignTW9kZWwgcGF0aDonLCBtb2RlbFBhdGgpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0YWNrIHRyYWNlOicsIGVycm9yLnN0YWNrKTtcclxuICAgICAgICBpc0xvYWRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBTZXQgZXJyb3IgbWVzc2FnZSBmb3IgZGlzcGxheVxyXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnQnVpbGQgZmFpbGVkIHRvIHJlbmRlcic7XHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcclxuICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBtaXNzaW5nIHBhcnRzIGVycm9yXHJcbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnTWlzc2luZyBwYXJ0cycpKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdDYW5ub3QgYmUgcmVuZGVyZWRcXG5NaXNzaW5nIExFR08gcGFydHMnO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgc3BlY2lmaWMgcGFydCB0aGF0IGZhaWxlZCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgcGFydE1hdGNoID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvXCIoW15cIl0rXFwuZGF0KVwiLyk7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0TWF0Y2gpIHtcclxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQnVpbGQgZmFpbGVkIHRvIHJlbmRlclxcbkludmFsaWQgcGFydDogJHtwYXJ0TWF0Y2hbMV19YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRMb2FkRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIH0pOyAgLy8gQ2xvc2UgdGhlIC5maW5hbGx5KCkgYmxvY2tcclxuXHJcbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uIC0gb25seSByZW1vdmUgbW9kZWwgaWYgcGF0aCBjaGFuZ2VzIG9yIGNvbXBvbmVudCB1bm1vdW50c1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcclxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb25zb2xlLndhcm4gaWYgaXQncyBiZWVuIG92ZXJyaWRkZW5cclxuICAgICAgaWYgKGNvbnNvbGUud2FybiAhPT0gb3JpZ2luYWxXYXJuKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuID0gb3JpZ2luYWxXYXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERvbid0IGNsZWFyIHRoZSBtb2RlbCBoZXJlIC0gaXQgd2lsbCBiZSBjbGVhcmVkIHdoZW4gYSBuZXcgbW9kZWwgbG9hZHNcclxuICAgICAgLy8gb3Igd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXHJcbiAgICB9O1xyXG4gIH0sIFttb2RlbFBhdGgsIGxkcmF3Q29udGVudF0pO1xyXG5cclxuICAvLyBDbGVhbiB1cCBtb2RlbCB3aGVuIGNvbXBvbmVudCB1bm1vdW50c1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAobW9kZWxHcm91cFJlZi5jdXJyZW50ICYmIHNjZW5lUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAvLyBNYXJrIGFzIGludmlzaWJsZSBmaXJzdFxyXG4gICAgICAgIG1vZGVsR3JvdXBSZWYuY3VycmVudC52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gVGhlbiByZW1vdmVcclxuICAgICAgICBzY2VuZVJlZi5jdXJyZW50LnJlbW92ZShtb2RlbEdyb3VwUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIG1vZGVsR3JvdXBSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgaXNMb2FkaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgY3VycmVudE1vZGVsUGF0aFJlZi5jdXJyZW50ID0gJyc7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgLy8gVXBkYXRlIHZpc2liaWxpdHkgYmFzZWQgb24gY3VycmVudCBzdGVwXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChhbGxQYXJ0c1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyB2aXNpYmlsaXR5IGZvciBzdGVwICR7Y3VycmVudFN0ZXB9IG9mICR7dG90YWxTdGVwc31gKTtcclxuXHJcbiAgICAvLyBTaG93L2hpZGUgcGFydHMgYmFzZWQgb24gY3VycmVudCBzdGVwXHJcbiAgICBhbGxQYXJ0c1JlZi5jdXJyZW50LmZvckVhY2gocGFydCA9PiB7XHJcbiAgICAgIGNvbnN0IHBhcnRTdGVwID0gcGFydC51c2VyRGF0YS5zdGVwTnVtYmVyIHx8IDE7XHJcbiAgICAgIHBhcnQudmlzaWJsZSA9IHBhcnRTdGVwIDw9IGN1cnJlbnRTdGVwO1xyXG4gICAgfSk7XHJcbiAgfSwgW2N1cnJlbnRTdGVwLCB0b3RhbFN0ZXBzXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IHN0eWxlPXt7IHBvc2l0aW9uOiAncmVsYXRpdmUnLCB3aWR0aDogJzEwMCUnIH19PlxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICBoZWlnaHQ6ICc2MDBweCcsXHJcbiAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI2NjYycsXHJcbiAgICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxyXG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcclxuICAgICAgICB9fVxyXG4gICAgICA+XHJcbiAgICAgICAge2xvYWRFcnJvciAmJiAoXHJcbiAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgdG9wOiAnNTAlJyxcclxuICAgICAgICAgICAgICBsZWZ0OiAnNTAlJyxcclxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxyXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSknLFxyXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcyMHB4IDMwcHgnLFxyXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXHJcbiAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCAycHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMSknLFxyXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgICAgekluZGV4OiAxMDBcclxuICAgICAgICAgICAgfX1cclxuICAgICAgICAgID5cclxuICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNkMzJmMmYnLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxOHB4JyxcclxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICc2MDAnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAnOHB4J1xyXG4gICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICDimqDvuI8ge2xvYWRFcnJvci5zcGxpdCgnXFxuJylbMF19XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7bG9hZEVycm9yLmluY2x1ZGVzKCdcXG4nKSAmJiAoXHJcbiAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgICAgY29sb3I6ICcjNjY2JyxcclxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcclxuICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAnOHB4J1xyXG4gICAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICB7bG9hZEVycm9yLnNwbGl0KCdcXG4nKVsxXX1cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICB7dG90YWxTdGVwcyA+IDEgJiYgKFxyXG4gICAgICAgIDxkaXYgc3R5bGU9e3tcclxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgYm90dG9tOiAnMjBweCcsXHJcbiAgICAgICAgICBsZWZ0OiAnNTAlJyxcclxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknLFxyXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KScsXHJcbiAgICAgICAgICBwYWRkaW5nOiAnMTVweCAyMHB4JyxcclxuICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXHJcbiAgICAgICAgICBib3hTaGFkb3c6ICcwIDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKScsXHJcbiAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXHJcbiAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcclxuICAgICAgICAgIGdhcDogJzE1cHgnLFxyXG4gICAgICAgICAgbWluV2lkdGg6ICc0MDBweCcsXHJcbiAgICAgICAgICB6SW5kZXg6IDEwMDBcclxuICAgICAgICB9fT5cclxuICAgICAgICAgIDxsYWJlbCBzdHlsZT17e1xyXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnIzMzMycsXHJcbiAgICAgICAgICAgIG1pbldpZHRoOiAnODBweCdcclxuICAgICAgICAgIH19PlxyXG4gICAgICAgICAgICBTdGVwIHtjdXJyZW50U3RlcH0ve3RvdGFsU3RlcHN9XHJcbiAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgIHR5cGU9XCJyYW5nZVwiXHJcbiAgICAgICAgICAgIG1pbj17MX1cclxuICAgICAgICAgICAgbWF4PXt0b3RhbFN0ZXBzfVxyXG4gICAgICAgICAgICB2YWx1ZT17Y3VycmVudFN0ZXB9XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0Q3VycmVudFN0ZXAocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKX1cclxuICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICBmbGV4OiAxLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogJzZweCcsXHJcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgIzRDQUY1MCAwJSwgIzRDQUY1MCAkeygoY3VycmVudFN0ZXAgLSAxKSAvICh0b3RhbFN0ZXBzIC0gMSkpICogMTAwfSUsICNkZGQgJHsoKGN1cnJlbnRTdGVwIC0gMSkgLyAodG90YWxTdGVwcyAtIDEpKSAqIDEwMH0lLCAjZGRkIDEwMCUpYCxcclxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICczcHgnLFxyXG4gICAgICAgICAgICAgIG91dGxpbmU6ICdub25lJyxcclxuICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICAgIDxkaXYgc3R5bGU9e3tcclxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxyXG4gICAgICAgICAgICBnYXA6ICc4cHgnXHJcbiAgICAgICAgICB9fT5cclxuICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEN1cnJlbnRTdGVwKE1hdGgubWF4KDEsIGN1cnJlbnRTdGVwIC0gMSkpfVxyXG4gICAgICAgICAgICAgIGRpc2FibGVkPXtjdXJyZW50U3RlcCA8PSAxfVxyXG4gICAgICAgICAgICAgIHN0eWxlPXt7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnNnB4IDEycHgnLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjdXJyZW50U3RlcCA+IDEgPyAnIzRDQUY1MCcgOiAnI2NjYycsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogY3VycmVudFN0ZXAgPiAxID8gJ3BvaW50ZXInIDogJ25vdC1hbGxvd2VkJyxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXHJcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcclxuICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAg4oaQIFByZXZcclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRDdXJyZW50U3RlcChNYXRoLm1pbih0b3RhbFN0ZXBzLCBjdXJyZW50U3RlcCArIDEpKX1cclxuICAgICAgICAgICAgICBkaXNhYmxlZD17Y3VycmVudFN0ZXAgPj0gdG90YWxTdGVwc31cclxuICAgICAgICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzZweCAxMnB4JyxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY3VycmVudFN0ZXAgPCB0b3RhbFN0ZXBzID8gJyM0Q0FGNTAnIDogJyNjY2MnLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXHJcbiAgICAgICAgICAgICAgICBjdXJzb3I6IGN1cnJlbnRTdGVwIDwgdG90YWxTdGVwcyA/ICdwb2ludGVyJyA6ICdub3QtYWxsb3dlZCcsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXHJcbiAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIE5leHQg4oaSXHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Q3VycmVudFN0ZXAoY3VycmVudFN0ZXAgPT09IHRvdGFsU3RlcHMgPyAxIDogdG90YWxTdGVwcyl9XHJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc2cHggMTJweCcsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjE5NkYzJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXHJcbiAgICAgICAgICAgICAgfX1cclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIHtjdXJyZW50U3RlcCA9PT0gdG90YWxTdGVwcyA/ICdSZXNldCcgOiAnQWxsJ31cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKX1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCBMRFJWaWV3ZXIgPSBtZW1vKExEUlZpZXdlckNvbXBvbmVudCk7XHJcbmV4cG9ydCBkZWZhdWx0IExEUlZpZXdlcjtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwibWVtbyIsIlRIUkVFIiwiT3JiaXRDb250cm9scyIsIkxEcmF3TG9hZGVyIiwiTERyYXdDb25kaXRpb25hbExpbmVNYXRlcmlhbCIsIkxEUlZpZXdlckNvbXBvbmVudCIsIm1vZGVsUGF0aCIsImxkcmF3Q29udGVudCIsInByZXNlcnZlQ2FtZXJhIiwiY29udGFpbmVyUmVmIiwic2NlbmVSZWYiLCJyZW5kZXJlclJlZiIsImNhbWVyYVJlZiIsImNvbnRyb2xzUmVmIiwibW9kZWxHcm91cFJlZiIsImxvYWRpbmdNYW5hZ2VyUmVmIiwiaXNMb2FkaW5nUmVmIiwiY3VycmVudE1vZGVsUGF0aFJlZiIsImlzSW5pdGlhbGl6ZWRSZWYiLCJlcnJvckNvdW50UmVmIiwibG9hZEVycm9yIiwic2V0TG9hZEVycm9yIiwidXNlU3RhdGUiLCJzYXZlZENhbWVyYVBvc2l0aW9uIiwic2F2ZWRDYW1lcmFUYXJnZXQiLCJjdXJyZW50U3RlcCIsInNldEN1cnJlbnRTdGVwIiwidG90YWxTdGVwcyIsInNldFRvdGFsU3RlcHMiLCJzdGVwc1JlZiIsImFsbFBhcnRzUmVmIiwiY3VycmVudCIsIm1hbmFnZXIiLCJMb2FkaW5nTWFuYWdlciIsInNldFVSTE1vZGlmaWVyIiwidXJsIiwibm9ybWFsaXplZCIsInJlcGxhY2UiLCJpbmNsdWRlcyIsIm1hdGNoIiwicGFydHMiLCJzcGxpdCIsImxhc3RUd28iLCJzbGljZSIsInVybFBhcnRzIiwiZmlsZW5hbWUiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImhhc1N1YmRpciIsInBhdGhQcmVmaXhlcyIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInVuZGVmaW5lZCIsImNvbnRhaW5lciIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY2VuZSIsIlNjZW5lIiwiYmFja2dyb3VuZCIsIkNvbG9yIiwiY2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJwb3NpdGlvbiIsInNldCIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFudGlhbGlhcyIsInNldFNpemUiLCJzZXRQaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsImNvbnRyb2xzIiwiZW5hYmxlRGFtcGluZyIsImRhbXBpbmdGYWN0b3IiLCJlbmFibGVQYW4iLCJlbmFibGVSb3RhdGUiLCJlbmFibGVab29tIiwic2NyZWVuU3BhY2VQYW5uaW5nIiwibWluRGlzdGFuY2UiLCJtYXhEaXN0YW5jZSIsInRhcmdldCIsImFkZCIsIkFtYmllbnRMaWdodCIsImRpckxpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsImNhc3RTaGFkb3ciLCJmaWxsTGlnaHQxIiwiZmlsbExpZ2h0MiIsImhlbWlMaWdodCIsIkhlbWlzcGhlcmVMaWdodCIsImF4ZXNIZWxwZXIiLCJBeGVzSGVscGVyIiwiaGFuZGxlUmVzaXplIiwidyIsImgiLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNvbnNvbGUiLCJsb2ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYW5pbWF0aW9uSWRSZWYiLCJpc0FuaW1hdGluZ1JlZiIsImFuaW1hdGUiLCJ3YXJuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFzTnVsbENoaWxkcmVuIiwibnVsbENoZWNrQ291bnQiLCJ0cmF2ZXJzZSIsImNoaWxkIiwiaGFzT3duUHJvcGVydHkiLCJlcnJvciIsImNoaWxkcmVuIiwiaSIsInNwbGljZSIsImlzRmluaXRlIiwieCIsInkiLCJ6IiwidXBkYXRlIiwiY2xlYW51cE51bGxPYmplY3RzIiwib2JqIiwidmFsaWRDaGlsZHJlbiIsInZpc2libGUiLCJwdXNoIiwicmVuZGVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjdXJyZW50SWRlbnRpZmllciIsInN1YnN0cmluZyIsImNsb25lIiwibW9kZWxUb1JlbW92ZSIsInNldFRpbWVvdXQiLCJyZW1vdmUiLCJnZW9tZXRyeSIsImRpc3Bvc2UiLCJtYXRlcmlhbCIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJtYXQiLCJjYW5jZWxsZWQiLCJsb2FkZXIiLCJzZXRQYXJ0c0xpYnJhcnlQYXRoIiwic21vb3RoTm9ybWFscyIsInNldEZpbGVNYXAiLCJzZXRDb25kaXRpb25hbExpbmVNYXRlcmlhbCIsIm1hdGVyaWFsc1Byb21pc2UiLCJwcmVsb2FkTWF0ZXJpYWxzIiwidGhlbiIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsIm9yaWdpbmFsV2FybiIsImhhc1N1Ym9iamVjdEVycm9yIiwiYXJncyIsImpvaW4iLCJhcHBseSIsImZpbmFsbHkiLCJtb2RlbFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInBhcnNlIiwiZ3JvdXAiLCJsb2FkQXN5bmMiLCJFcnJvciIsInNhZmVUcmF2ZXJzZSIsImlzTWVzaCIsIm1lc2giLCJNZXNoUGhvbmdNYXRlcmlhbCIsImNvbG9yIiwic2lkZSIsIkRvdWJsZVNpZGUiLCJuYW1lIiwibWFwIiwicm90YXRpb24iLCJNYXRoIiwiUEkiLCJtZXNoQ291bnQiLCJ2aXNpYmxlQ291bnQiLCJib3VuZGluZ0JveCIsImNvbXB1dGVCb3VuZGluZ0JveCIsImdlb21ldHJ5VmVydGljZXMiLCJhdHRyaWJ1dGVzIiwiY291bnQiLCJzY2FsZSIsInVwZGF0ZU1hdHJpeFdvcmxkIiwiYm94IiwiQm94MyIsInNldEZyb21PYmplY3QiLCJjZW50ZXIiLCJnZXRDZW50ZXIiLCJWZWN0b3IzIiwic2l6ZSIsImdldFNpemUiLCJpc0VtcHR5IiwiY29weSIsInN0YWNrIiwiZXJyb3JNZXNzYWdlIiwicGFydE1hdGNoIiwicGFydCIsInBhcnRTdGVwIiwidXNlckRhdGEiLCJzdGVwTnVtYmVyIiwiZGl2Iiwic3R5bGUiLCJyZWYiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJvdmVyZmxvdyIsInRvcCIsImxlZnQiLCJ0cmFuc2Zvcm0iLCJiYWNrZ3JvdW5kQ29sb3IiLCJwYWRkaW5nIiwiYm94U2hhZG93IiwidGV4dEFsaWduIiwiekluZGV4IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luVG9wIiwiYm90dG9tIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJnYXAiLCJtaW5XaWR0aCIsImxhYmVsIiwiaW5wdXQiLCJ0eXBlIiwibWluIiwibWF4IiwidmFsdWUiLCJvbkNoYW5nZSIsImUiLCJwYXJzZUludCIsImZsZXgiLCJvdXRsaW5lIiwiY3Vyc29yIiwiYnV0dG9uIiwib25DbGljayIsImRpc2FibGVkIiwiTERSVmlld2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/LDRViewer.tsx\n"));

/***/ })

});